// The porth to wasm compiler implemented over the Porth reference implementation in itself

include "4std.porth"

/// BEGIN Loc //////////////////////////////
/// Loc is a location within the source code: file path, row, col
const Loc.file-path sizeof(Str) offset end
const Loc.row sizeof(u64) offset end
const Loc.col sizeof(u64) offset end
const sizeof(Loc) reset end

inline proc bputloc ptr ptr in
  let loc bfd in
    loc Loc.file-path ptr+ @Str bfd bputs
    ":"                         bfd bputs
    loc Loc.row ptr+ @64        bfd bputu
    ":"                         bfd bputs
    loc Loc.col ptr+ @64        bfd bputu
  end
end

inline proc fputloc ptr int in
  let loc fd in
    loc Loc.file-path ptr+ @Str fd fputs
    ":"                         fd fputs
    loc Loc.row ptr+ @64        fd fputu
    ":"                         fd fputs
    loc Loc.col ptr+ @64        fd fputu
  end
end
inline proc putloc ptr in stdout fputloc end
inline proc eputloc ptr in stderr fputloc end
/// END Loc //////////////////////////////

/// BEGIN Token //////////////////////////////
/// Token is a group of characters within the source code that is
/// recognized as certain class: int, word, string, etc.
const TOKEN_INT     1 offset end
const TOKEN_WORD    1 offset end
const TOKEN_KEYWORD 1 offset end
const TOKEN_STR     1 offset end
const TOKEN_CSTR    1 offset end
const TOKEN_CHAR    1 offset end
const COUNT_TOKENS     reset end

const KEYWORD_IF          1 offset end
const KEYWORD_IFSTAR      1 offset end
const KEYWORD_ELSE        1 offset end
const KEYWORD_END         1 offset end
const KEYWORD_WHILE       1 offset end
const KEYWORD_DO          1 offset end
const KEYWORD_INCLUDE     1 offset end
const KEYWORD_MEMORY      1 offset end
const KEYWORD_PROC        1 offset end
const KEYWORD_CONST       1 offset end
const KEYWORD_OFFSET      1 offset end
const KEYWORD_RESET       1 offset end
const KEYWORD_ASSERT      1 offset end
const KEYWORD_IN          1 offset end
const KEYWORD_BIKESHEDDER 1 offset end
const KEYWORD_INLINE      1 offset end
const KEYWORD_HERE        1 offset end
const KEYWORD_ADDR_OF     1 offset end
const KEYWORD_CALL_LIKE   1 offset end
const KEYWORD_LET         1 offset end
const KEYWORD_PEEK        1 offset end
const KEYWORD_IMPORT      1 offset end
const COUNT_KEYWORDS         reset end

proc keyword-by-name
  int ptr
  --
  int bool
in
  memory name sizeof(Str) end
  name !Str
  true
  assert "Exhaustive keyword handling" COUNT_KEYWORDS 22 = end
       name @Str "if"        streq if  KEYWORD_IF
  else name @Str "if*"       streq if* KEYWORD_IFSTAR
  else name @Str "else"      streq if* KEYWORD_ELSE
  else name @Str "end"       streq if* KEYWORD_END
  else name @Str "while"     streq if* KEYWORD_WHILE
  else name @Str "do"        streq if* KEYWORD_DO
  else name @Str "include"   streq if* KEYWORD_INCLUDE
  else name @Str "memory"    streq if* KEYWORD_MEMORY
  else name @Str "proc"      streq if* KEYWORD_PROC
  else name @Str "const"     streq if* KEYWORD_CONST
  else name @Str "offset"    streq if* KEYWORD_OFFSET
  else name @Str "reset"     streq if* KEYWORD_RESET
  else name @Str "assert"    streq if* KEYWORD_ASSERT
  else name @Str "in"        streq if* KEYWORD_IN
  else name @Str "--"        streq if* KEYWORD_BIKESHEDDER
  else name @Str "inline"    streq if* KEYWORD_INLINE
  else name @Str "here"      streq if* KEYWORD_HERE
  else name @Str "addr-of"   streq if* KEYWORD_ADDR_OF
  else name @Str "call-like" streq if* KEYWORD_CALL_LIKE
  else name @Str "let"       streq if* KEYWORD_LET
  else name @Str "peek"      streq if* KEYWORD_PEEK
  else name @Str "import"    streq if* KEYWORD_IMPORT
  else
    drop false 0
  end

  swap
end

proc keyword-name
  int
  --
  int ptr
in
  assert "Exhaustive keyword handling" COUNT_KEYWORDS 22 = end
       dup KEYWORD_IF          = if  "if"
  else dup KEYWORD_IFSTAR      = if* "if*"
  else dup KEYWORD_ELSE        = if* "else"
  else dup KEYWORD_END         = if* "end"
  else dup KEYWORD_WHILE       = if* "while"
  else dup KEYWORD_DO          = if* "do"
  else dup KEYWORD_INCLUDE     = if* "include"
  else dup KEYWORD_MEMORY      = if* "memory"
  else dup KEYWORD_PROC        = if* "proc"
  else dup KEYWORD_CONST       = if* "const"
  else dup KEYWORD_OFFSET      = if* "offset"
  else dup KEYWORD_RESET       = if* "reset"
  else dup KEYWORD_ASSERT      = if* "assert"
  else dup KEYWORD_IN          = if* "in"
  else dup KEYWORD_BIKESHEDDER = if* "--"
  else dup KEYWORD_INLINE      = if* "inline"
  else dup KEYWORD_HERE        = if* "here"
  else dup KEYWORD_ADDR_OF     = if* "addr-of"
  else dup KEYWORD_CALL_LIKE   = if* "call-like"
  else dup KEYWORD_LET         = if* "let"
  else dup KEYWORD_PEEK        = if* "peek"
  else dup KEYWORD_IMPORT      = if* "import"
  else
    0 NULL
    here eputs ": unreachable\n" eputs
    1 exit
  end
  rot drop
end

const Token.type sizeof(u64) offset end
const Token.loc  sizeof(Loc) offset end
const Token.text sizeof(Str) offset end
const Token.value
   sizeof(u64)
   sizeof(Str)
   max
   offset
end
const sizeof(Token) reset end
/// END Token //////////////////////////////

/// BEGIN Strbuf //////////////////////////////
/// The buffer that holds the date of the string literals of
/// the compiled program. (see Strlit)
const STRBUF_CAP 32 1024 * end
memory strbuf-size sizeof(int) end
memory strbuf-start STRBUF_CAP end

inline proc strbuf-end -- ptr in strbuf-start strbuf-size @int ptr+ end
proc strbuf-append-char int in
  strbuf-size @int STRBUF_CAP >= if
    here eputs ": Assertion Failed: string literal buffer overflow\n" eputs
    1 exit
  end

  strbuf-end !8
  strbuf-size inc64
end

proc strbuf-append-str int ptr in
  memory str sizeof(Str) end
  str !Str

  while str @Str.count 0 > do
    str @Str.data @8 strbuf-append-char
    str str-chop-one-left
  end
end

proc strbuf-loc
  ptr // loc
  --
  int ptr
in
  memory start sizeof(ptr) end
  strbuf-end start !ptr

  dup Loc.file-path ptr+ @Str   strbuf-append-str
  ":"                           strbuf-append-str
  dup Loc.row ptr+ @64 tmp-utos strbuf-append-str
  ":"                           strbuf-append-str
  dup Loc.col ptr+ @64 tmp-utos strbuf-append-str
  drop

  strbuf-end start @ptr ptr-diff
  start @ptr
end
/// END Strbuf //////////////////////////////

/// BEGIN Lexer //////////////////////////////
/// Lexer is an entity that turns a string into a sequence of Tokens
const Lexer.content    sizeof(Str) offset end
const Lexer.line       sizeof(Str) offset end
const Lexer.line-start sizeof(ptr) offset end
const Lexer.file-path  sizeof(Str) offset end
const Lexer.row        sizeof(u64) offset end
const sizeof(Lexer) reset end

inline proc lexer-next-line ptr in
  let lexer in
    '\n'
    lexer Lexer.line ptr+
    lexer Lexer.content ptr+
    str-chop-by-delim

    lexer Lexer.line ptr+ offsetof(Str.data) ptr+ @ptr
    lexer Lexer.line-start ptr+
    !ptr

    lexer Lexer.row ptr+ inc64
  end
end

inline proc lexer-get-loc
  ptr // loc
  ptr // lexer
in
  let loc lexer in
    // File Path
    sizeof(Str)
    lexer Lexer.file-path ptr+
    loc   Loc.file-path   ptr+
    memcpy
    drop

    // Row
    lexer Lexer.row ptr+ @int
    loc   Loc.row   ptr+ !int

    // Column
    lexer Lexer.line ptr+ offsetof(Str.data) ptr+ @ptr
    lexer Lexer.line-start ptr+ @ptr
    ptr-diff
    1 +
    loc Loc.col ptr+
    !int
  end
end

proc lexer-consume-str-like-lit
  ptr // lexer
  int // quote
  --
  int ptr // string literal
  bool    // closed
in
  memory quote sizeof(int) end
  quote !int

  memory lexer sizeof(ptr) end
  lexer !ptr

  memory start sizeof(ptr) end
  strbuf-end start !ptr

  memory count sizeof(int) end
  0 count !int

  memory loc sizeof(Loc) end

  memory closed sizeof(bool) end
  false closed !bool

  lexer @ptr Lexer.line ptr+
    while
      dup ?str-empty lnot if
        dup @Str.data @8 quote @int = if
          dup str-chop-one-left
          true closed !bool
          false
        else dup @Str.data @8 '\\' = if*
          dup str-chop-one-left

          dup ?str-empty if
            loc lexer @ptr lexer-get-loc
            loc eputloc ": ERROR: unfinished escape sequence\n" eputs
            1 exit
          end

          dup @Str.data @8 'n' = if
            '\n' strbuf-append-char
            dup str-chop-one-left
            count inc64
            true
          else dup @Str.data @8 'r' = if*
            '\r' strbuf-append-char
            dup str-chop-one-left
            count inc64
            true
          else dup @Str.data @8 '\\' = if*
            '\\' strbuf-append-char
            dup str-chop-one-left
            count inc64
            true
          else dup @Str.data @8 '\"' = if*
            '\"' strbuf-append-char
            dup str-chop-one-left
            count inc64
            true
          else dup @Str.data @8 '\'' = if*
            '\'' strbuf-append-char
            dup str-chop-one-left
            count inc64
            true
          else
            loc lexer @ptr lexer-get-loc
            loc eputloc ": ERROR: unknown escape character `" eputs 1 over @Str.data eputs "`\n" eputs
            1 exit
            false
          end
        else
          dup @Str.data @8 strbuf-append-char
          dup str-chop-one-left
          count inc64
          true
        end
      else false end
    do end
  drop

  count @int start @ptr closed @bool
end

proc lexer-consume-strlit
  ptr // lexer
  int // quote
  --
  int ptr // string literal
in
  memory loc sizeof(Loc) end
  memory lexer sizeof(ptr) end
  over lexer !ptr
  lexer-consume-str-like-lit lnot if
    loc lexer @ptr lexer-get-loc
    loc eputloc ": ERROR: unclosed string literal\n" eputs
    1 exit
  end
end

proc lexer-consume-charlit
  ptr // lexer
  int // quote
  --
  int ptr // char literal
in
  memory loc sizeof(Loc) end
  memory lexer sizeof(ptr) end
  over lexer !ptr
  lexer-consume-str-like-lit lnot if
    loc lexer @ptr lexer-get-loc
    loc eputloc ": ERROR: unclosed character literal\n" eputs
    1 exit
  end
end

proc lexer-next-token
  ptr // token
  ptr // lexer
  --
  bool
in
  memory lexer sizeof(ptr) end
  lexer !64
  memory token sizeof(ptr) end
  token !64

  memory word sizeof(Str) end

  lexer @ptr
  while
    dup Lexer.line ptr+ str-trim-left

    dup Lexer.line ptr+ ?str-empty if
      dup Lexer.content ptr+ ?str-empty lnot
    else
      dup Lexer.line ptr+
      // TODO: `69//` is recognized as a single word
      // And not a number plus a comment
      "//" rot @Str str-starts-with
    end
  do dup lexer-next-line end

  dup Lexer.line ptr+ ?str-empty lnot if
    token @ptr Token.loc ptr+
    lexer @ptr
    lexer-get-loc

    assert "Exhaustive token types handling in lexer-next-token" COUNT_TOKENS 6 = end

    dup Lexer.line ptr+ @Str.data @8 '"' = if
       // String literal
       dup Lexer.line ptr+ str-chop-one-left
       '"' lexer-consume-strlit word !Str
       word @Str token @ptr Token.value ptr+ !Str

       lexer @ptr Lexer.line ptr+ ?str-empty lnot if
         lexer @ptr Lexer.line ptr+ @Str.data @8 'c' = if
           lexer @ptr Lexer.line ptr+ str-chop-one-left
           0 strbuf-append-char
           token @ptr Token.value ptr+ offsetof(Str.count) ptr+ inc64
           TOKEN_CSTR token @ptr Token.type ptr+ !64
         else
           TOKEN_STR token @ptr Token.type ptr+ !64
         end
       else
         TOKEN_STR token @ptr Token.type ptr+ !64
       end
    else dup Lexer.line ptr+ @Str.data @8 '\'' = if*
       // Character literal
       dup Lexer.line ptr+ str-chop-one-left
       '\'' lexer-consume-charlit word !Str

       word @Str.count 1 = if
         word @Str.data @8 token @ptr Token.value ptr+ !int
       else
         token @ptr Token.loc ptr+ eputloc ": ERROR: only a single byte is allowed inside of a character literal\n" eputs
         1 exit
       end

       TOKEN_CHAR token @ptr Token.type ptr+ !64
    else
       // Word or integer literal

       addr-of ?space
       word
       rot Lexer.line ptr+
       str-chop-by-predicate

       word @Str try-parse-int if
         token @ptr Token.value ptr+ !64
         TOKEN_INT token @ptr Token.type ptr+ !64
       else drop word @Str try-parse-hex if*
         token @ptr Token.value ptr+ !64
         TOKEN_INT token @ptr Token.type ptr+ !64
       else drop word @Str keyword-by-name if*
         token @ptr Token.value ptr+ !64
         TOKEN_KEYWORD token @ptr Token.type ptr+ !64
       else drop
         word @Str  token @ptr Token.value ptr+ !Str
         TOKEN_WORD token @ptr Token.type ptr+ !64
       end
    end

    word @Str token @ptr Token.text ptr+ !Str

    true
  else
    drop // lexer
    false
  end
end

proc lex-file ptr in
  memory file-path-cstr sizeof(ptr) end
  file-path-cstr !64

  memory lexer sizeof(Lexer) end
  sizeof(Lexer) 0 lexer memset drop
  file-path-cstr @ptr map-file    lexer Lexer.content   ptr+ !Str
  file-path-cstr @ptr cstr-to-str lexer Lexer.file-path ptr+ !Str

  memory token sizeof(Token) end

  while token lexer lexer-next-token do

    assert "Exhaustive handling of token types in lex-file" COUNT_TOKENS 6 = end

    token Token.loc ptr+ // loc
    dup Loc.file-path ptr+ @Str puts ":" puts
    dup Loc.row ptr+ @64 putu        ":" puts
    dup Loc.col ptr+ @64 putu        ": " puts
    drop // loc

    token Token.type ptr+ @64 // token.type
    dup TOKEN_INT = if
      "[INTEGER] " puts token Token.value ptr+ @int putu "\n" puts
    else dup TOKEN_WORD = if*
      "[WORD] " puts token Token.value ptr+ @Str puts "\n" puts
    else dup TOKEN_STR = if*
      "[STR] \"" puts token Token.value ptr+ @Str puts "\"\n" puts
    else dup TOKEN_CSTR = if*
      "[CSTR] \"" puts token Token.value ptr+ @Str puts "\"\n" puts
    else dup TOKEN_CHAR = if*
      "[CHAR] " puts token Token.value ptr+ @int putu "\n" puts
    else dup TOKEN_KEYWORD = if*
      "[KEYWORD] " puts token Token.value ptr+ @int keyword-name puts "\n" puts
    else
      here eputs ": Unreachable. Unknown token type.\n" eputs
      1 exit
    end

    drop // token.type
  end
end
/// END Lexer //////////////////////////////

/// BEGIN DataType //////////////////////////////
const DATATYPE_INT  1 offset end
const DATATYPE_PTR  1 offset end
const DATATYPE_BOOL 1 offset end
const DATATYPE_ADDR 1 offset end
const COUNT_DATATYPES  reset end

const HUMAN_SINGULAR 1 offset end
const HUMAN_PLURAL   1 offset end
const COUNT_HUMAN       reset end

proc human-token-type
  int // token type
  int // plurality
  --
  int ptr // str
in
  assert "Exhaustive handling of noun categories" COUNT_HUMAN 2 = end

  dup HUMAN_SINGULAR = if
    drop
    assert "Exhaustive handling of token types" COUNT_TOKENS 6 = end
    dup TOKEN_INT = if
      drop
      "an integer"
    else dup TOKEN_WORD = if*
      drop
      "a word"
    else dup TOKEN_STR = if*
      drop
      "a string"
    else dup TOKEN_CSTR = if*
      drop
      "a C-style string"
    else dup TOKEN_CHAR = if*
      drop
      "a character"
    else dup TOKEN_KEYWORD = if*
      drop
      "a keyword"
    else
      drop
      here eputs ": unreachable\n" eputs
      0 NULL
    end
  else dup HUMAN_PLURAL = if*
    drop
    assert "Exhaustive handling of token types" COUNT_TOKENS 6 = end
    dup TOKEN_INT = if
      drop
      "integers"
    else dup TOKEN_WORD = if*
      drop
      "words"
    else dup TOKEN_STR = if*
      drop
      "strings"
    else dup TOKEN_CSTR = if*
      drop
      "C-style strings"
    else dup TOKEN_CHAR = if*
      drop
      "characters"
    else dup TOKEN_KEYWORD = if*
      drop
      "keywords"
    else
      drop
      here eputs ": unreachable\n" eputs
      69 exit
      0 NULL
    end
  else
    drop drop
    here eputs ": unreachable\n" eputs
    69 exit
    0 NULL
  end
end

proc datatype-by-name
  int ptr // data type name
  --
  int // data type
  bool // found
in
  memory name sizeof(Str) end
  name !Str
  assert "Exhaustive handling of data types in datatype-by-name" COUNT_DATATYPES 4 = end
       name @Str "ptr"  streq if  DATATYPE_PTR  true
  else name @Str "bool" streq if* DATATYPE_BOOL true
  else name @Str "int"  streq if* DATATYPE_INT  true
  else name @Str "addr" streq if* DATATYPE_ADDR true
  else 0 false end
end

proc datatype-name
  int // data type
  --
  int ptr
in
  assert "Exhaustive handling of data types in datatype-name" COUNT_DATATYPES 4 = end
       dup DATATYPE_INT  = if  drop "int"
  else dup DATATYPE_BOOL = if* drop "bool"
  else dup DATATYPE_PTR  = if* drop "ptr"
  else dup DATATYPE_ADDR = if* drop "addr"
  else
    drop
    0 NULL
    here eputs ": unreachable\n" eputs
    69 exit
  end
end

/// END DataType //////////////////////////////

/// BEGIN Intrinsics //////////////////////////////
/// Intrinsics are built-in function of the language with the hardcoded implementation.
const INTRINSIC_PLUS      1 offset end
const INTRINSIC_MINUS     1 offset end
const INTRINSIC_MUL       1 offset end
const INTRINSIC_DIVMOD    1 offset end
const INTRINSIC_IDIVMOD   1 offset end
const INTRINSIC_MAX       1 offset end
const INTRINSIC_EQ        1 offset end
const INTRINSIC_GT        1 offset end
const INTRINSIC_LT        1 offset end
const INTRINSIC_GE        1 offset end
const INTRINSIC_LE        1 offset end
const INTRINSIC_NE        1 offset end
const INTRINSIC_SHR       1 offset end
const INTRINSIC_SHL       1 offset end
const INTRINSIC_OR        1 offset end
const INTRINSIC_AND       1 offset end
const INTRINSIC_NOT       1 offset end
const INTRINSIC_XOR       1 offset end
const INTRINSIC_PRINT     1 offset end
const INTRINSIC_DUP       1 offset end
const INTRINSIC_SWAP      1 offset end
const INTRINSIC_DROP      1 offset end
const INTRINSIC_OVER      1 offset end
const INTRINSIC_ROT       1 offset end
const INTRINSIC_LOAD8     1 offset end
const INTRINSIC_STORE8    1 offset end
const INTRINSIC_LOAD16    1 offset end
const INTRINSIC_STORE16   1 offset end
const INTRINSIC_LOAD32    1 offset end
const INTRINSIC_STORE32   1 offset end
const INTRINSIC_LOAD64    1 offset end
const INTRINSIC_STORE64   1 offset end
assert "Exhaustive cast intrinsic definition" COUNT_DATATYPES 4 = end
const INTRINSIC_CAST_PTR  1 offset end
const INTRINSIC_CAST_INT  1 offset end
const INTRINSIC_CAST_BOOL 1 offset end
const INTRINSIC_CAST_ADDR 1 offset end
const INTRINSIC_ARGC      1 offset end
const INTRINSIC_ARGV      1 offset end
const INTRINSIC_ENVP      1 offset end
const INTRINSIC_SYSCALL0  1 offset end
const INTRINSIC_SYSCALL1  1 offset end
const INTRINSIC_SYSCALL2  1 offset end
const INTRINSIC_SYSCALL3  1 offset end
const INTRINSIC_SYSCALL4  1 offset end
const INTRINSIC_SYSCALL5  1 offset end
const INTRINSIC_SYSCALL6  1 offset end
const INTRINSIC_???       1 offset end
const COUNT_INTRINSICS       reset end

proc intrinsic-name
  int // intrinsic
  --
  int ptr // name
in
  assert "Exhaustive handling of Intrinsics in intrinsic-name" COUNT_INTRINSICS 47 = end
       dup INTRINSIC_PLUS      = if  drop "+"
  else dup INTRINSIC_MINUS     = if* drop "-"
  else dup INTRINSIC_MUL       = if* drop "*"
  else dup INTRINSIC_DIVMOD    = if* drop "divmod"
  else dup INTRINSIC_IDIVMOD   = if* drop "idivmod"
  else dup INTRINSIC_MAX       = if* drop "max"
  else dup INTRINSIC_PRINT     = if* drop "print"
  else dup INTRINSIC_EQ        = if* drop "="
  else dup INTRINSIC_GT        = if* drop ">"
  else dup INTRINSIC_LT        = if* drop "<"
  else dup INTRINSIC_GE        = if* drop ">="
  else dup INTRINSIC_LE        = if* drop "<="
  else dup INTRINSIC_NE        = if* drop "!="
  else dup INTRINSIC_SHR       = if* drop "shr"
  else dup INTRINSIC_SHL       = if* drop "shl"
  else dup INTRINSIC_OR        = if* drop "or"
  else dup INTRINSIC_AND       = if* drop "and"
  else dup INTRINSIC_NOT       = if* drop "not"
  else dup INTRINSIC_XOR       = if* drop "xor"
  else dup INTRINSIC_DUP       = if* drop "dup"
  else dup INTRINSIC_SWAP      = if* drop "swap"
  else dup INTRINSIC_DROP      = if* drop "drop"
  else dup INTRINSIC_OVER      = if* drop "over"
  else dup INTRINSIC_ROT       = if* drop "rot"
  else dup INTRINSIC_STORE8    = if* drop "!8"
  else dup INTRINSIC_LOAD8     = if* drop "@8"
  else dup INTRINSIC_STORE16   = if* drop "!16"
  else dup INTRINSIC_LOAD16    = if* drop "@16"
  else dup INTRINSIC_STORE32   = if* drop "!32"
  else dup INTRINSIC_LOAD32    = if* drop "@32"
  else dup INTRINSIC_STORE64   = if* drop "!64"
  else dup INTRINSIC_LOAD64    = if* drop "@64"
  else dup INTRINSIC_CAST_PTR  = if* drop "cast(ptr)"
  else dup INTRINSIC_CAST_INT  = if* drop "cast(int)"
  else dup INTRINSIC_CAST_BOOL = if* drop "cast(bool)"
  else dup INTRINSIC_CAST_ADDR = if* drop "cast(addr)"
  else dup INTRINSIC_ARGC      = if* drop "argc"
  else dup INTRINSIC_ARGV      = if* drop "argv"
  else dup INTRINSIC_ENVP      = if* drop "envp"
  else dup INTRINSIC_SYSCALL0  = if* drop "syscall0"
  else dup INTRINSIC_SYSCALL1  = if* drop "syscall1"
  else dup INTRINSIC_SYSCALL2  = if* drop "syscall2"
  else dup INTRINSIC_SYSCALL3  = if* drop "syscall3"
  else dup INTRINSIC_SYSCALL4  = if* drop "syscall4"
  else dup INTRINSIC_SYSCALL5  = if* drop "syscall5"
  else dup INTRINSIC_SYSCALL6  = if* drop "syscall6"
  else dup INTRINSIC_???       = if* drop "???"
  else
    drop 0 NULL
    here eputs ": unreachable\n" eputs
    1 exit
  end
end

proc intrinsic-by-name
  int ptr // name
  --
  int     // intrinsic
  bool    // found
in
  memory name sizeof(Str) end
  name !Str
  true
  assert "Exhaustive handling of Intrinsics in intrinsic-by-name" COUNT_INTRINSICS 47 = end
       name @Str "+"          streq if  INTRINSIC_PLUS
  else name @Str "-"          streq if* INTRINSIC_MINUS
  else name @Str "*"          streq if* INTRINSIC_MUL
  else name @Str "divmod"     streq if* INTRINSIC_DIVMOD
  else name @Str "idivmod"    streq if* INTRINSIC_IDIVMOD
  else name @Str "max"        streq if* INTRINSIC_MAX
  else name @Str "print"      streq if* INTRINSIC_PRINT
  else name @Str "="          streq if* INTRINSIC_EQ
  else name @Str ">"          streq if* INTRINSIC_GT
  else name @Str "<"          streq if* INTRINSIC_LT
  else name @Str ">="         streq if* INTRINSIC_GE
  else name @Str "<="         streq if* INTRINSIC_LE
  else name @Str "!="         streq if* INTRINSIC_NE
  else name @Str "shr"        streq if* INTRINSIC_SHR
  else name @Str "shl"        streq if* INTRINSIC_SHL
  else name @Str "or"         streq if* INTRINSIC_OR
  else name @Str "and"        streq if* INTRINSIC_AND
  else name @Str "not"        streq if* INTRINSIC_NOT
  else name @Str "xor"        streq if* INTRINSIC_XOR
  else name @Str "dup"        streq if* INTRINSIC_DUP
  else name @Str "swap"       streq if* INTRINSIC_SWAP
  else name @Str "drop"       streq if* INTRINSIC_DROP
  else name @Str "over"       streq if* INTRINSIC_OVER
  else name @Str "rot"        streq if* INTRINSIC_ROT
  else name @Str "!8"         streq if* INTRINSIC_STORE8
  else name @Str "@8"         streq if* INTRINSIC_LOAD8
  else name @Str "!16"        streq if* INTRINSIC_STORE16
  else name @Str "@16"        streq if* INTRINSIC_LOAD16
  else name @Str "!32"        streq if* INTRINSIC_STORE32
  else name @Str "@32"        streq if* INTRINSIC_LOAD32
  else name @Str "!64"        streq if* INTRINSIC_STORE64
  else name @Str "@64"        streq if* INTRINSIC_LOAD64
  else name @Str "cast(ptr)"  streq if* INTRINSIC_CAST_PTR
  else name @Str "cast(int)"  streq if* INTRINSIC_CAST_INT
  else name @Str "cast(bool)" streq if* INTRINSIC_CAST_BOOL
  else name @Str "cast(addr)" streq if* INTRINSIC_CAST_ADDR
  else name @Str "argc"       streq if* INTRINSIC_ARGC
  else name @Str "argv"       streq if* INTRINSIC_ARGV
  else name @Str "envp"       streq if* INTRINSIC_ENVP
  else name @Str "syscall0"   streq if* INTRINSIC_SYSCALL0
  else name @Str "syscall1"   streq if* INTRINSIC_SYSCALL1
  else name @Str "syscall2"   streq if* INTRINSIC_SYSCALL2
  else name @Str "syscall3"   streq if* INTRINSIC_SYSCALL3
  else name @Str "syscall4"   streq if* INTRINSIC_SYSCALL4
  else name @Str "syscall5"   streq if* INTRINSIC_SYSCALL5
  else name @Str "syscall6"   streq if* INTRINSIC_SYSCALL6
  else name @Str "???"        streq if* INTRINSIC_???
  else
    drop false 0
  end
  swap
end
/// END Intrinsics //////////////////////////////

/// BEGIN Op //////////////////////////////
/// "Op" is a single operation within the Porth's Intermediate Representation (IR):
/// https://en.wikipedia.org/wiki/Intermediate_representation

// TODO: make conditional and unconditional jumps jump by relative address
// This will make the code more relocatable which will make it easily inlinable

assert "Exhaustive push IR instructions definition for data types. For each data type we must have a corresponding OP_PUSH_<TYPE> instruction." COUNT_DATATYPES 4 = end
// OP_PUSH_INT: Push an integer onto the data stack.
//
// operand type:    int
// operand purpose: The number we are pushing.
const OP_PUSH_INT        1 offset end
// OP_PUSH_BOOL: Push a boolean onto the data stack.
//
// operand type:    bool
// operand purpose: The boolean we are pushing.
const OP_PUSH_BOOL       1 offset end
// OP_PUSH_PTR: Push a pointer onto the data stack.
//
// operand type:    ptr
// operand purpose: The pointer we are pushing.
const OP_PUSH_PTR        1 offset end
// OP_PUSH_ADDR: Push a procedure address onto the data stack.
//
// operand type:    addr
// operand purpose: The procedure address we are pushing.
const OP_PUSH_ADDR       1 offset end
// OP_PUSH_LOCAL_MEM: Push a pointer to a local memory region that is
// located in the return stack onto the data stack.
//
// operand type:    int
// operand purpose: The offset from the top of the return stack in bytes.
//                  The pushed pointer should be an absolute value computed
//                  at runtime using the provided offset.
const OP_PUSH_LOCAL_MEM  1 offset end
// OP_PUSH_GLOBAL_MEM: Push a pointer to a global memory region onto
// the data stack.
//
// operand type:    int
// operand purpose: The offset from the start of the uninitialized global
//                  memory region. The pushed pointer should be an absolute
//                  value computed at compile time using the provided offset.
const OP_PUSH_GLOBAL_MEM 1 offset end
// OP_PUSH_STR: Push a sized string onto the data stack. Actually
// pushes two words onto the data stack. The first word is the size of
// the string. The second word is the pointer to an initialized global
// memory region containing the characters of the string.
//
// operand type:    int
// operand purpose: An index in the global strlits array
//                  (See Strlit section).
const OP_PUSH_STR        1 offset end
// OP_PUSH_CSTR: Push an unsized NULL-terminated C-style string onto
// the data stack. Pushes a pointer to an initialized global memory
// region containing the characters of the string. The sequence of
// characters of the string always ends with '\0'.
//
// operand type:    int
// operand purpose: An index in strlits array (See Strlit section for more information).
const OP_PUSH_CSTR       1 offset end
// OP_IF: Performs a conditional jump based on the consumed value from
// the top of the data stack. If the value is `false` jump by the
// provided address offset forward, otherwise "fall-through" to the
// next instruction. The target jump offset - 1 should be always
// pointing at OP_END_IF or OP_ELSE instruction denoting the
// boundaries of the if-block.
//
// operand type:    int
// operand purpose: The address offset to jump by forward
//                  when the consumed value is `false`.
const OP_IF              1 offset end
// OP_IFSTAR: Performs a conditional jump based on the consumed value
// from the top of the data stack. If the value is `false` jump by the
// provided address offset forward, otherwise "fall-through" to the
// next instruction. Always follows OP_ELSE instruction. The target
// jump address offset - 1 should be always pointing at OP_END_IF or
// OP_ELSE instruction denoting the boundaries of the if-block.
//
// operand type:    int
// operand purpose: The address offset to jump by forward
//                  when the consumed value is `false`.
const OP_IFSTAR          1 offset end
// OP_ELSE: Performs an unconditional jump. Always follows OP_IF or
// OP_IFSTAR instruction. Always jumps to another OP_ELSE or OP_END_IF
// instruction to short-circuit the entire if-else-if*-end chain when
// the right condition is found.
//
// TODO: We need to double check the invariants stated above. I don't
// remember 100% if OP_ELSE works like this right now.
//
// operand type:    int
// operand purpose: The address offset to jump by forward.
const OP_ELSE            1 offset end
// OP_END_IF: Denotes the end of the if-else-if* block. Does not
// really do anything else. Follows OP_IF, OP_ELSE or OP_IFSTAR
// instructions. Could be simply ignored during target-specific code
// generation.
//
// operand type:    void
// operand purpose: ignored
const OP_END_IF          1 offset end
// OP_END_WHILE: Performs an unconditional jump to OP_WHILE
// instruction denoting the end of the while-do block. Follows OP_DO
// instruction. The address offset should be always used to jump
// *BACKWARDS*.
//
// operand type:    int
// operand purpose: the address offset to jump by *BACKWARDS*.
const OP_END_WHILE       1 offset end
// OP_PREP_PROC: Denotes the start of the procedure. Could be used by
// the targets as an opportuinity to do target specific procedure
// preparation.
//
// operand type:    int
// operand purpose: the amount of bytes of local memory to allocate
//                  on the return stack.
const OP_PREP_PROC       1 offset end
// OP_RET: Return from the procedure call.
//
// operand type:    int
// operand purpose: the amount of bytes of local memory to deallocate
//                  from the return stack before trying to pop an actual
//                  return address from it.
const OP_RET             1 offset end
// OP_CALL: Call a procedure.
//
// TODO: the operand should be an index in the procs array (See Proc section).
// This will make the procedures more relocatable which may help with
// Dead Code Elimination.
//
// operand type:    addr
// operand purpose: the address of the procedure to call
const OP_CALL            1 offset end
// OP_INLINED: Denotes the start of the sequence of instructions that
// were inlined from another procedure. The end of such sequence is
// denoted by the size of the inlined procedure.
//
// operand type:    int
// operand purpose: the index of the inlined procedure in the global
//                  procs array (See Proc section)
const OP_INLINED         1 offset end
// OP_WHILE: Denotes the beginning of the while loop. Acts like a
// label for the corresponding OP_END_WHILE instruction.
//
// operand type:    addr
// operand purpose: The address offset to jump by forward to reach the instruction
//                  after the corresponding OP_END_WHILE. Denotes the size
//                  of the while loop. Can be used by a type checker to
//                  skip the whole loop after it was properly type checked.
const OP_WHILE           1 offset end
// OP_DO: Performs a conditional jump based on the consumed value from
// the top of the data stack. If the value is `false` jump by the
// provided address offset forward, otherwise "fall-through" to the
// next instruction. Always follows OP_WHILE instruction. The target
// jump address offset - 1 should be always pointing at OP_END_WHILE
// instruction denoting the boundaries of the while-do-end-block.
//
// operand type:    addr
// operand purpose: The address offset to jump by forward
//                  when the consumed value is `false`.
const OP_DO              1 offset end
// OP_INTRINSIC: Calls a built in intrinsic procedure.
//
// operand type:    int
// operand purpose: the id number of the intrinsic procedure
//                  (See Intrinsics section)
const OP_INTRINSIC       1 offset end
// OP_CALL_LIKE: Calls a procedure by the addresss consumed from the
// top of the data stack.
//
// operand type:    int
// operand purpose: the index of the procedure in the global procs array (See Procs Section)
//                  to use to type check the call.
const OP_CALL_LIKE       1 offset end
// OP_BIND_LET: Pops N elements from the top of the data stack and
// pushes them to the return stack
//
// operand type:    int
// operand purpose: the amount of elements to "bind"
const OP_BIND_LET        1 offset end
// OP_BIND_PEEK: Takes N elements from the top of the data stack and
// pushes them to the return stack without removing them from the data
// stack.
//
// operand type:    int
// operand purpose: the amount of elements to "bind"
const OP_BIND_PEEK       1 offset end
// OP_PUSH_BIND: Pushes the value of the bound variable from the
// return stack onto the data stack
//
// operand type:    int
// operand purpose: the index of the value on the return stack to push onto the data stack.
//                  The indexing starts from top of the return stack.
const OP_PUSH_BIND       1 offset end
// OP_UNBIND: Removes N elements from the return stack.
//
// operand type:    int
// operand purpose: the amount of elements to "unbind"
const OP_UNBIND          1 offset end
const COUNT_OPS             reset end

proc op-type-as-str
  int // Op type
  --
  int ptr // str
in
  assert "Exhaustive handling of Op types in print-op-type" COUNT_OPS 25 = end
       dup OP_PUSH_INT        =  if  "OP_PUSH_INT"
  else dup OP_PUSH_BOOL       =  if* "OP_PUSH_BOOL"
  else dup OP_PUSH_PTR        =  if* "OP_PUSH_PTR"
  else dup OP_PUSH_ADDR       =  if* "OP_PUSH_ADDR"
  else dup OP_PUSH_GLOBAL_MEM =  if* "OP_PUSH_GLOBAL_MEM"
  else dup OP_PUSH_LOCAL_MEM  =  if* "OP_PUSH_LOCAL_MEM"
  else dup OP_PUSH_STR        =  if* "OP_PUSH_STR"
  else dup OP_PUSH_CSTR       =  if* "OP_PUSH_CSTR"
  else dup OP_INTRINSIC       =  if* "OP_INTRINSIC"
  else dup OP_IF              =  if* "OP_IF"
  else dup OP_IFSTAR          =  if* "OP_IFSTAR"
  else dup OP_ELSE            =  if* "OP_ELSE"
  else dup OP_END_IF          =  if* "OP_END_IF"
  else dup OP_END_WHILE       =  if* "OP_END_WHILE"
  else dup OP_PREP_PROC       =  if* "OP_PREP_PROC"
  else dup OP_RET             =  if* "OP_RET"
  else dup OP_CALL            =  if* "OP_CALL"
  else dup OP_INLINED         =  if* "OP_INLINED"
  else dup OP_WHILE           =  if* "OP_WHILE"
  else dup OP_DO              =  if* "OP_DO"
  else dup OP_CALL_LIKE       =  if* "OP_CALL_LIKE"
  else dup OP_BIND_LET        =  if* "OP_BIND_LET"
  else dup OP_BIND_PEEK       =  if* "OP_BIND_PEEK"
  else dup OP_UNBIND          =  if* "OP_UNBIND"
  else dup OP_PUSH_BIND       =  if* "OP_PUSH_BIND"
  else
    here eputs ": Unknown op type\n" eputs 1 exit
    0 NULL
  end
  rot drop
end

const Op.type    sizeof(u64)   offset end
const Op.operand sizeof(u64)   offset end
const Op.token   sizeof(Token) offset end
const sizeof(Op) reset end

const OPS_CAP 64 1024 * end
memory ops-count sizeof(u64) end
memory ops sizeof(Op) OPS_CAP * end

proc push-op
  int // type
  int // operand
  ptr // token
in
  memory op sizeof(Op) end
  sizeof(Token) swap op Op.token ptr+ memcpy drop
  op Op.operand ptr+ !int
  op Op.type ptr+ !int

  sizeof(Op) op OPS_CAP ops ops-count append-item lnot if
    here eputs ": ERROR: ops overflow\n" eputs 1 exit
  end
  drop
end

inline proc push-op-by-ptr
  ptr // ptr to op struct
in
  dup Op.type    ptr+ @int swap
  dup Op.operand ptr+ @int swap
  dup Op.token   ptr+      swap drop
  push-op
end

proc dump-ops in
  0
    while dup ops-count @64 < do
      dup sizeof(Op) * ops +ptr
        dup Op.token ptr+ Token.loc ptr+ putloc ": " puts
        over putu " => " puts
        dup Op.type ptr+ @64 op-type-as-str puts " " puts
        dup Op.type ptr+ @64 OP_INTRINSIC = if
          dup Op.operand ptr+ @64 intrinsic-name puts
        else
          dup Op.operand ptr+ @64 putu
        end
        "\n" puts
      drop
      1 +
    end
  drop
end
/// END Op ////////////////////////////

/// BEGIN Strlit //////////////////////////////
/// Array of string literals of the compiled program.
/// The operand of OP_PUSH_STR and OP_PUSH_CSTR is the
/// index within this array
const STRLITS_CAP 2 1024 * end
memory strlits-count sizeof(int) end
memory strlits sizeof(Str) STRLITS_CAP * end

proc strlit-define
  int ptr
  --
  int
in
  memory strlit sizeof(Str) end
  strlit !Str

  sizeof(Str) strlit
  STRLITS_CAP strlits
  strlits-count
  append-item lnot if
    here eputs ": ERROR: string literals capacity exceeded\n" eputs
    1 exit
  end
end
/// END Strlit //////////////////////////////

/// BEGIN Const //////////////////////////////
/// Array of the constants of the compiled program
const Const.name  sizeof(Str) offset end
const Const.loc   sizeof(Loc) offset end
const Const.value sizeof(u64) offset end
const Const.type  sizeof(u64) offset end
const sizeof(Const) reset end

// TODO: forbid constant definition inside of proc

const CONST_CAP 1024 end
memory consts sizeof(Const) CONST_CAP * end
memory consts-count sizeof(u64) end

proc const-lookup
  int ptr // name
  --
  ptr     // ptr to const struct
in
  memory name sizeof(Str) end
  name !Str

  0 while
    dup consts-count @64 < if
      dup sizeof(Const) * consts +ptr Const.name ptr+ @Str
      name @Str
      streq
      lnot
    else false end
  do 1 + end

  dup consts-count @64 < if
    sizeof(Const) * consts +ptr
  else
    drop NULL
  end
end

proc const-define
  ptr // ptr to const struct
in
  sizeof(Const) swap CONST_CAP consts consts-count append-item lnot if
    here eputs ": ERROR: constants definitions capacity exceeded\n" eputs
    1 exit
  end
  drop
end
/// END Const //////////////////////////////

/// BEGIN TypeStack //////////////////////////////
const TypeFrame.type sizeof(int) offset end
const TypeFrame.loc  sizeof(Loc) offset end
const TypeFrame.prev sizeof(ptr) offset end
const sizeof(TypeFrame)           reset end

const TypeStack.top   sizeof(ptr) offset end
const TypeStack.count sizeof(int) offset end
const sizeof(TypeStack)            reset end

const TYPE_FRAME_POOL_CAP 16 1024 * end
memory type-frame-pool TYPE_FRAME_POOL_CAP sizeof(TypeFrame) * end
memory type-frame-pool-count sizeof(int) end

proc type-frame-alloc -- ptr in
  type-frame-pool-count @int TYPE_FRAME_POOL_CAP >= if
    here eputs ": ERROR: Type Frame Pool overflow! Time to implement proper memory management! Or you can just increase the size of the pool, that will work too. Kappa\n" eputs
    1 exit
  end

  type-frame-pool-count @int
  sizeof(TypeFrame) *
  type-frame-pool +ptr

  type-frame-pool-count inc64
end

proc type-stack-push
  int // type
  ptr // Loc
  ptr // stack
in
  memory stack sizeof(ptr) end
  stack !ptr

  memory new-top sizeof(ptr) end
  type-frame-alloc new-top !ptr

  sizeof(Loc) swap new-top @ptr TypeFrame.loc ptr+ memcpy drop
  new-top @ptr TypeFrame.type ptr+ !int

  stack   @ptr TypeStack.top  ptr+ @ptr
  new-top @ptr TypeFrame.prev ptr+ !ptr

  new-top @ptr
  stack   @ptr TypeStack.top ptr+ !ptr

  stack   @ptr TypeStack.count ptr+ inc64
end

proc type-stack-push-frame
  ptr // frame
  ptr // stack
in
  swap
  dup  TypeFrame.type ptr+ @int
  swap TypeFrame.loc ptr+
  rot
  type-stack-push
end

proc type-stack-pop
  ptr // stack
in
  dup TypeStack.count ptr+ dec64
  TypeStack.top ptr+
  dup @ptr NULL ptr!= if
    dup @ptr TypeFrame.prev ptr+ @ptr
    swap
    !ptr
  else drop end
end

proc ?type-stack-empty ptr -- bool in TypeStack.top ptr+ @ptr NULL ptr= end

proc type-stack-dump
  ptr // type stack
  int // fd
in
  memory fd sizeof(int) end
  fd !int
  TypeStack.top ptr+ @ptr
    while dup NULL ptr!= do
      dup TypeFrame.loc ptr+                     fd @int fputloc
      ": NOTE: type `"                           fd @int fputs
      dup TypeFrame.type ptr+ @int datatype-name fd @int fputs
      "`\n"                                      fd @int fputs

      TypeFrame.prev ptr+ @ptr
    end
  drop
end

proc type-stack-reverse
  ptr // ins
  --
  ptr // outs
in
  memory outs sizeof(ptr) end
  sizeof(TypeStack) tmp-alloc outs !ptr

  TypeStack.top ptr+ @ptr
    while dup NULL ptr!= do
      dup TypeFrame.type ptr+ @int
      over TypeFrame.loc ptr+
      outs @ptr
      type-stack-push

      TypeFrame.prev ptr+ @ptr
    end
  drop

  outs @ptr
end

/// END TypeStack //////////////////////////////

/// BEGIN Proc //////////////////////////////
/// Array of procedures of the compiled program
const Proc.name sizeof(Str)       offset end
const Proc.addr sizeof(u64)       offset end
const Proc.loc  sizeof(Loc)       offset end
const Proc.ins  sizeof(TypeStack) offset end
const Proc.outs sizeof(TypeStack) offset end
const Proc.inlinable sizeof(bool) offset end
const Proc.imported sizeof(bool)  offset end
const Proc.size sizeof(int)       offset end
const sizeof(Proc)                 reset end
const PROCS_CAP 1024 end
memory procs-count sizeof(u64) end
memory procs sizeof(Proc) PROCS_CAP * end
memory inside-proc sizeof(bool) end

proc proc-lookup-by-name
  int ptr // proc name
  --
  ptr     // proc
in
  memory name sizeof(Str) end
  name !Str

  0 while
    dup procs-count @64 < if
      dup sizeof(Proc) * procs +ptr Proc.name ptr+ @Str
      name @Str
      streq
      lnot
    else false end
  do 1 + end

  dup procs-count @64 < if
    sizeof(Proc) * procs +ptr
  else
    drop NULL
  end
end

proc proc-lookup-by-addr
  int // proc addr
  --
  ptr // proc
in
  memory addr sizeof(int) end
  addr !int

  0 while
    dup procs-count @64 < if
      dup sizeof(Proc) * procs +ptr Proc.addr ptr+ @int
      addr @int
      !=
    else false end
  do 1 + end

  dup procs-count @64 < if
    sizeof(Proc) * procs +ptr
  else
    drop NULL
  end
end


proc proc-define
  ptr // proc
in
  sizeof(Proc) swap PROCS_CAP procs procs-count append-item lnot if
    here eputs ": ERROR: procedure definitions capacity exceeded\n" eputs
    1 exit
  end
  drop
end
/// END Proc //////////////////////////////

/// BEGIN Memory //////////////////////////////
const Memory.name sizeof(Str) offset end
const Memory.offset sizeof(u64) offset end
const Memory.loc sizeof(Loc) offset end
const sizeof(Memory) reset end

const GLOBAL_MEMORIES_CAP 1024 end
memory global-memories-count sizeof(u64) end
memory global-memories sizeof(Memory) GLOBAL_MEMORIES_CAP * end
memory global-memory-capacity sizeof(u64) end

const LOCAL_MEMORIES_CAP 1024 end
memory local-memories-count sizeof(u64) end
memory local-memories sizeof(Memory) LOCAL_MEMORIES_CAP * end
memory local-memory-capacity sizeof(u64) end

inline proc local-memories-clean in
  0 local-memories-count !64
  0 local-memory-capacity !64
end

proc local-memories-lookup
  int ptr // name
  --
  ptr     // Memory
in
  memory name sizeof(Str) end
  name !Str

  0 while
    dup local-memories-count @64 < if
      dup sizeof(Memory) * local-memories +ptr Memory.name ptr+ @Str
      name @Str
      streq
      lnot
    else false end
  do 1 + end

  dup local-memories-count @64 < if
    sizeof(Memory) * local-memories +ptr
  else
    drop NULL
  end
end

proc global-memories-lookup
  int ptr // name
  --
  ptr     // Memory
in
  memory name sizeof(Str) end
  name !Str

  0 while
    dup global-memories-count @64 < if
      dup sizeof(Memory) * global-memories +ptr Memory.name ptr+ @Str
      name @Str
      streq
      lnot
    else false end
  do 1 + end

  dup global-memories-count @64 < if
    sizeof(Memory) * global-memories +ptr
  else
    drop NULL
  end
end

proc local-memory-define
  ptr
in
  sizeof(Memory) swap LOCAL_MEMORIES_CAP local-memories local-memories-count append-item lnot if
    here eputs ": ERROR: local memory definitions capacity exceeded\n" eputs
    1 exit
  end
  drop
end

proc global-memory-define
  ptr
in
  sizeof(Memory) swap GLOBAL_MEMORIES_CAP global-memories global-memories-count append-item lnot if
    here eputs ": ERROR: global memory definitions capacity exceeded\n" eputs
    1 exit
  end
  drop
end
/// END Memory //////////////////////////////

memory silent sizeof(bool) end

inline proc located-here ptr in eputloc ": NOTE: located here\n" eputs end

// TODOO: an option to detect stack overflow at runtime
const X86_64_RET_STACK_CAP 64 1024 * end

/// BEGIN Code Generator //////////////////////////////
proc bputdecstr
  int ptr
  ptr
in
  let n s bfd in
    true n s
    while over 0 > do
      let first n s in
        first lnot if "," bfd bputs end
        s @8 bfd bputu

        false
        n 1 -
        s 1 ptr+
      end
    end
    drop drop drop
  end
end

proc bputhexchar
  int
  ptr
in
  let bfd in 
    dup  
    '0'  >   over
    '9'  <=  land if 
    '0'   -  bfd  bputu
    else
    @hex     bfd  bputs end
  end
end

proc bputhexint 
  int ptr 
in
  let bfd in
    char-to-hex     
    over 1 > if
      dup @8
      bfd bputhexchar 
      inc-Str 
    else  
      "0" 
      bfd bputs
    end   
    @8 
    bfd bputhexchar 
    drop 
  end
end

proc bputwatstr
  int ptr
  ptr
in
  let bfd in
    "\""          bfd bputs
    while over 0 > do 
      dup @8
      char-to-hex
      "\\"     bfd bputs
      while over 0 > do
        dup @8 bfd bputhexchar
        inc-Str
      end drop drop
      inc-Str
    end "\""   bfd bputs
  end
  drop drop
end

proc generate-op-comment ptr ptr in
  let op bfd in
    op Op.type    ptr+ @int
    op Op.operand ptr+ @int
    op Op.token   ptr+
    let type operand token in
      " ;; "                      bfd bputs
      // token Token.loc ptr+     bfd bputloc
      // ": "                     bfd bputs
      type OP_INTRINSIC = if
       token Token.text ptr+ @Str bfd bputs
      else 
        type op-type-as-str       bfd bputs
        " "                       bfd bputs
        operand                   bfd bputu
      end
      "\n"                        bfd bputs
    end
  end
end

memory wat-global-mem sizeof(int) end
memory wat-data-stack sizeof(int) end
memory wat-string-mem sizeof(int) end

memory skip-inline sizeof(bool) end
memory skip-op sizeof(int) end

proc generate-op-wat
  int // ip
  ptr // bfd
in
  let ip bfd in
    skip-op @int 0 > if
      skip-op dec64
    else
      ip sizeof(Op) * ops +ptr
      let op in
        op Op.type ptr+ @int
        op Op.operand ptr+ @int
        let type operand in
          assert "Exhaustive handling of Op types in generate-op-wat" COUNT_OPS 25 = end
          skip-inline @bool  if
          else type OP_RET = if*
             ")" bfd bputs
          else type OP_PUSH_INT = if*
             " i32.const "   bfd bputs operand bfd bputu
             " call $push"   bfd bputs
          else type OP_PUSH_BOOL = if*
             " i32.const "   bfd bputs operand bfd bputu
             " call $push"   bfd bputs
          else type OP_PUSH_PTR = if*
             " i32.const "   bfd bputs operand bfd bputu
             " call $push"   bfd bputs
          else type OP_PUSH_ADDR = if*
             here puts ": FIXME: not implemented yet\n" puts
             1 exit
          else type OP_CALL_LIKE = if*
             here puts ": FIXME: not implemented yet\n" puts
             1 exit
          else type OP_BIND_LET = if*
             here puts ": FIXME: not implemented yet\n" puts
             1 exit
          else type OP_BIND_PEEK = if*
             here puts ": FIXME: not implemented yet\n" puts
             1 exit
          else type OP_UNBIND = if*
             here puts ": FIXME: not implemented yet\n" puts
             1 exit
          else type OP_PUSH_BIND = if*
             here puts ": FIXME: not implemented yet\n" puts
             1 exit
          else type OP_PUSH_LOCAL_MEM = if*
             1 while dup ip + sizeof(Op) * ops +ptr Op.type ptr+ @int OP_INLINED = do
               skip-op inc64
               1 +
             end
             ip + sizeof(Op) * ops +ptr 
             let nextOp in
              nextOp Op.type ptr+ @int OP_INTRINSIC = if
                nextOp Op.operand ptr+ @int 
                  dup INTRINSIC_STORE32 =  
                  over INTRINSIC_STORE64 = lor
                  over INTRINSIC_STORE16 = lor
                  over INTRINSIC_STORE8 = lor if drop
                    skip-op inc64
                    " call $pop"    bfd bputs 
                    " local.set "   bfd bputs operand sizeof(u64) / bfd bputu
                else
                  dup INTRINSIC_LOAD32 =  
                  over INTRINSIC_LOAD64 = lor
                  over INTRINSIC_LOAD16 = lor
                  swap INTRINSIC_LOAD8 = lor if
                    skip-op inc64
                  else 0 skip-op !int end 
                  " local.get "   bfd bputs operand sizeof(u64) / bfd bputu
                  " call $push"   bfd bputs
                end
              else 0 skip-op !int end
             end
          else type OP_PUSH_GLOBAL_MEM = if*
             " i32.const "      bfd bputs operand bfd bputu
             " i32.const "      bfd bputs wat-global-mem @int bfd bputu
             " i32.add "        bfd bputs 
             " call $push"      bfd bputs
          else type OP_PUSH_STR = if*
             " i32.const "      bfd bputs op Op.token ptr+ Token.value ptr+ @Str drop bfd bputu
             " call $push"      bfd bputs
             " global.get $str" bfd bputs operand bfd bputu
             " call $push"      bfd bputs
          else type OP_PUSH_CSTR = if*
             " global.get $str" bfd bputs operand bfd bputu
             " call $push"      bfd bputs
          else type OP_IF = if*
             " call $pop"   bfd bputs
             " if" bfd bputs
          else type OP_IFSTAR = if*
             here puts ": FIXME: not implemented yet\n" puts
             1 exit
          else type OP_ELSE = if*
             " else" bfd bputs
          else type OP_END_WHILE = if*
             " br $" bfd bputs operand 1 + bfd bputu
             " end"  bfd bputs
             " end"  bfd bputs
          else type OP_END_IF = if*
             " end" bfd bputs
          else type OP_WHILE = if*
             " block $while" bfd bputs 
             " loop $"       bfd bputs operand bfd bputu
          else type OP_DO = if*
             " call $pop"    bfd bputs
             " i32.eqz"      bfd bputs
             " br_if $while" bfd bputs
          else type OP_PREP_PROC = if*
              op Op.token ptr+ Token.text ptr+ dup @Str proc-lookup-by-name
              let name prok in
                prok NULL ptr= if
                  here eputs ": Assertion Failed: couldn't find proc name by token text" eputs
                  1 exit
                end
                prok Proc.inlinable ptr+ @bool if
                  true skip-inline !bool
                else prok Proc.imported ptr+ @bool if*
                  true skip-inline !bool
                  "(import \"env\" \"" bfd bputs
                  name @Str            bfd bputs
                  "\" (func $f"        bfd bputs ip bfd bputu
                  prok Proc.ins ptr+
                  TypeStack.top ptr+ @ptr
                  dup NULL ptr!= if
                    " (param"         bfd bputs
                    while dup NULL ptr!= do
                      " i32"          bfd bputs
                      TypeFrame.prev ptr+ @ptr
                    end drop
                    ")"               bfd bputs
                  else drop end
                  "))\n"              bfd bputs
                else
                  false skip-inline !bool
                  "\n(func $f" bfd bputs ip bfd bputu                  
                  operand 0 > if
                    " (local"  bfd bputs 
                    operand 0 while over over > do
                      " i32"  bfd bputs
                      sizeof(u64) +
                    end  drop drop
                    ")"  bfd bputs
                  end
                end
              end
          else type OP_CALL = if*
              op Op.token ptr+ Token.text ptr+ @Str proc-lookup-by-name
              let prok in
                prok NULL ptr= if
                  here eputs ": Assertion Failed: couldn't find proc name by token text" eputs
                  1 exit
                end
                prok Proc.imported ptr+ @bool if
                  prok Proc.ins ptr+
                  TypeStack.top ptr+ @ptr 
                  dup NULL ptr!= if
                    while dup NULL ptr!= do
                      " call $pop" bfd bputs
                      TypeFrame.prev ptr+ @ptr
                    end drop
                  else drop end
                end
                " call $f" bfd bputs
                prok Proc.name ptr+ @Str "rnd" streq if
                  "rnd"   bfd bputs
                else
                  operand bfd bputu
                end
              end
          else type OP_INLINED = if*
          else type OP_INTRINSIC = if*
              assert "Exhaustive handling of Intrinsics in generate-op-wat"
                COUNT_INTRINSICS 47 =
              end

              operand INTRINSIC_PLUS = if
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.add"           bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_MINUS = if*
                  " call $swap"        bfd bputs
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.sub"           bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_MUL = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.mul"           bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_DIVMOD = if*
                  " call $divmod"     bfd bputs
              else operand INTRINSIC_IDIVMOD = if*
                  " call $divmod"     bfd bputs
              else operand INTRINSIC_MAX = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " f32.convert_i32_u" bfd bputs
                  " f32.convert_i32_u" bfd bputs
                  " f32.max "          bfd bputs
                  " i32.trunc_f32_u"   bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_SHR = if*
                  " call $swap"        bfd bputs
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.shr_u"         bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_SHL = if*
                  " call $swap"        bfd bputs
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.shl"           bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_OR = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.or"            bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_AND = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.and"           bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_XOR = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.xor"           bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_NOT = if*
                  " call $pop"         bfd bputs
                  " if"                bfd bputs
                  " i32.const 0"       bfd bputs
                  " call $push"        bfd bputs
                  " else"              bfd bputs
                  " i32.const 1"       bfd bputs
                  " call $push"        bfd bputs
                  " end\n"             bfd bputs
              else operand INTRINSIC_PRINT = if*
                  // " call $drop"        bfd bputs
                  here puts ": FIXME: not implemented yet\n" puts
                  1 exit
              else operand INTRINSIC_EQ = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.eq"            bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_GT = if*
                  " call $swap"        bfd bputs
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.gt_u"          bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_LT = if*
                  " call $swap"        bfd bputs
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.lt_u"          bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_GE = if*
                  " call $swap"        bfd bputs
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.ge_u"          bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_LE = if*
                  " call $swap"        bfd bputs
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.le_u"          bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_NE = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.ne"            bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_DUP = if*
                  " call $dup"         bfd bputs
              else operand INTRINSIC_SWAP = if*
                  " call $swap"        bfd bputs
              else operand INTRINSIC_DROP = if*
                  " call $drop"        bfd bputs
              else operand INTRINSIC_OVER = if*
                  " call $over"        bfd bputs
              else operand INTRINSIC_ROT = if*
                  " call $rot"         bfd bputs
              else operand INTRINSIC_LOAD8 = if*
                  " call $pop"         bfd bputs
                  " i32.load8_u"       bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_STORE8 = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.store8"        bfd bputs
              else operand INTRINSIC_LOAD16 = if*
                  " call $pop"         bfd bputs
                  " i32.load16_u"      bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_STORE16 = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.store16"       bfd bputs
              else operand INTRINSIC_LOAD32 = if*
                  " call $pop"         bfd bputs
                  " i32.load"          bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_STORE32 = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.store"         bfd bputs
              else operand INTRINSIC_LOAD64 = if*
                  " call $pop"         bfd bputs
                  " i32.load"          bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_STORE64 = if*
                  " call $pop"         bfd bputs
                  " call $pop"         bfd bputs
                  " i32.store"         bfd bputs
              else operand INTRINSIC_ARGC = if*
              else operand INTRINSIC_ARGV = if*
              else operand INTRINSIC_ENVP = if*
              else operand INTRINSIC_CAST_PTR = if*
              else operand INTRINSIC_CAST_INT = if*
              else operand INTRINSIC_CAST_BOOL = if*
                  " call $pop"         bfd bputs
                  " i32.eqz i32.eqz"      bfd bputs
                  " call $push"        bfd bputs
              else operand INTRINSIC_CAST_ADDR = if*
              else operand INTRINSIC_SYSCALL0 = if*
              else operand INTRINSIC_SYSCALL1 = if*
              else operand INTRINSIC_SYSCALL2 = if*
              else operand INTRINSIC_SYSCALL3 = if*
              else operand INTRINSIC_SYSCALL4 = if*
              else operand INTRINSIC_SYSCALL5 = if*
              else operand INTRINSIC_SYSCALL6 = if*
              else operand INTRINSIC_??? = if*
              else
                here eputs ": unreachable. Invalid intrinsic.\n" eputs
                1 exit
              end
          else
            here eputs ": unreachable. Invalid op.\n" eputs
            1 exit
          end
          skip-inline @bool if
            type OP_RET = if
              false skip-inline !bool
            end
          else
            op bfd generate-op-comment
            // "\n" bfd bputs
          end
        end
      end
    end
  end
end

memory char-counter sizeof(int) end

proc generate-wat
  ptr // file-path
in
  memory bfd sizeof(Bfd) end
  sizeof(Bfd) 0 bfd memset drop

  let file-path in
    silent @bool lnot if
      "[INFO] Generating "  puts
      file-path cstr-to-str puts
      "\n"                  puts
    end

    420                            // mode
    O_CREAT O_WRONLY or O_TRUNC or // flags
    file-path                      // pathname
    AT_FDCWD
    openat

    BFD_CAP tmp-alloc
    let fd buff in
      fd   bfd Bfd.fd  ptr+ !int
      buff bfd Bfd.buff ptr+ !ptr

      fd 0 < if
        "[ERROR] could not open file\n" eputs
        1 exit
      end

      "(import \"env\" \"memory\" (memory 1))\n" bfd bputs

      8192  wat-global-mem !int //0x2000
      9472  wat-data-stack !int //0x2500
      13568 wat-string-mem !int //0x3500

      0 while dup ops-count @64 < do
        dup bfd generate-op-wat
        1 +
      end drop

      "\n(func $dup (local i32)\n"                     bfd bputs
      "  call $pop  local.tee 0\n"                     bfd bputs
      "  call $push local.get 0\n"                     bfd bputs
      "  call $push)\n\n"                              bfd bputs
      "(func $swap (local i32)\n"                      bfd bputs
      "  call $pop\n"                                  bfd bputs
      "  call $pop  local.set 0\n"                     bfd bputs
      "  call $push local.get 0\n"                     bfd bputs
      "  call $push)\n\n"                              bfd bputs
      "(func $over (local i32 i32)\n"                  bfd bputs
      "  call $pop  local.set 1\n"                     bfd bputs
      "  call $pop  local.tee 0\n"                     bfd bputs
      "  call $push local.get 1\n"                     bfd bputs
      "  call $push local.get 0\n"                     bfd bputs
      "  call $push)\n\n"                              bfd bputs
      "(func $drop call $pop drop)\n\n"                bfd bputs
      "(func $rot (local i32)\n"                       bfd bputs
      "  call $pop\n"                                  bfd bputs
      "  call $pop\n"                                  bfd bputs
      "  call $pop  local.set 0\n"                     bfd bputs
      "  call $push\n"                                 bfd bputs
      "  call $push local.get 0\n"                     bfd bputs
      "  call $push)\n\n"                              bfd bputs
      "(func $push (param i32)  (local $offset i32)\n" bfd bputs
      "  global.get  $DATA_STACK \n"                   bfd bputs
      "  global.get  $DATA_STACK i32.load\n"           bfd bputs
      "  local.tee   $offset \n"                       bfd bputs
      "  i32.const 4 i32.add     i32.add\n"            bfd bputs
      "  local.get 0 \n"                               bfd bputs
      "  i32.store\n"                                  bfd bputs
      "  global.get  $DATA_STACK\n"                    bfd bputs
      "  local.get   $offset \n"                       bfd bputs
      "  i32.const 4 i32.add\n"                        bfd bputs
      "  i32.store)\n\n"                               bfd bputs
      "(func $pop (result i32) (local $offset i32)\n"  bfd bputs
      "  global.get  $DATA_STACK \n"                   bfd bputs
      "  global.get  $DATA_STACK i32.load\n"           bfd bputs
      "  local.tee   $offset\n"                        bfd bputs
      "  i32.add     i32.load\n"                       bfd bputs
      "  global.get  $DATA_STACK\n"                    bfd bputs
      "  local.get   $offset \n"                       bfd bputs
      "  i32.const 4 i32.sub\n"                        bfd bputs
      "  i32.store)\n\n"                               bfd bputs
      "(func $divmod (local i32 i32)\n"                bfd bputs
      "  call $swap\n"                                 bfd bputs
      "  call $pop   local.tee 0\n"                    bfd bputs
      "  call $pop   local.tee 1\n"                    bfd bputs
      "  i32.rem_u\n"                                  bfd bputs
      "  local.get 0 local.get 1\n"                    bfd bputs
      "  i32.div_u\n"                                  bfd bputs
      "  call $push call $push)\n"                     bfd bputs

      "main" proc-lookup-by-name
      let main-proc in
        main-proc NULL ptr= if
          here eputs ": Assertion Failed: type checking phase did not check the existence of `main` procedure" eputs
          1 exit
        end

        "\n(func (export \"start\")\n" bfd bputs
        "  call $f"                    bfd bputs
        main-proc Proc.addr ptr+ @int  bfd bputu
        "\n)\n"                        bfd bputs
      end

      "update" proc-lookup-by-name
      let update-proc in
        update-proc NULL ptr= if
          here eputs ": Assertion Failed: `update` procedure is missing" eputs
          1 exit
        end

        "\n(func (export \"update\")\n" bfd bputs
        "  call $f"                     bfd bputs
        update-proc Proc.addr ptr+ @int bfd bputu
        "\n)\n"                       bfd bputs
      end

      "rnd" proc-lookup-by-name
      let prok in
        prok NULL ptr= lnot if 
        "\n(global $random-state (mut i32) (i32.const 1234))\n" bfd bputs
        "\n(func $frnd (local i32)\n"        bfd bputs
        "  global.get   $random-state\n"     bfd bputs
        "  local.tee 0  local.get 0\n"       bfd bputs
        "  i32.const 13 i32.shl\n"           bfd bputs
        "  i32.xor      local.tee 0\n"       bfd bputs
        "  local.get 0  i32.const 17\n"      bfd bputs
        "  i32.shr_u    i32.xor\n"           bfd bputs
        "  local.tee 0  local.get 0\n"       bfd bputs
        "  i32.const 5  i32.shl\n"           bfd bputs
        "  i32.xor      local.tee 0\n"       bfd bputs
        "  global.set   $random-state\n"     bfd bputs
        "  local.get 0  i32.const 8\n"       bfd bputs
        "  i32.shr_u    f32.convert_i32_u\n" bfd bputs
        "  f32.const 0x1p-24 f32.mul\n"      bfd bputs
        "  call $pop    f32.convert_i32_u\n" bfd bputs
        "  f32.mul      i32.trunc_f32_u\n"   bfd bputs
        "  call $push)\n"                    bfd bputs
        end
      end

      "\n(global $DATA_STACK i32 (i32.const " bfd bputs wat-data-stack @int bfd bputu "))\n\n" bfd bputs
      
      0 char-counter !int
      0 while dup strlits-count @64 < do
        let i in
          i sizeof(Str) * strlits +ptr
          let str in
            str ?str-empty lnot if
              "(global $str"     bfd bputs i bfd bputu
              " i32 (i32.const " bfd bputs
              char-counter @int  wat-string-mem @int + bfd bputu
              "))\n"             bfd bputs
              char-counter @int  str @Str drop + char-counter !int
            end
          end
          i 1 +
        end
      end drop

      "\n(data (i32.const " bfd bputs wat-string-mem @int bfd bputu ")\n" bfd bputs
      
      0 while dup strlits-count @64 < do
        let i in
          i sizeof(Str) * strlits +ptr
          let str in
            str ?str-empty lnot if
              "  "     bfd bputs
              str @Str bfd bputwatstr
            end
          end
          "\n" bfd bputs
          i 1 +
        end
      end drop
      ")" bfd bputs

      bfd bflush
      fd close drop
      buff tmp-rewind
    end
  end
end

/// END Code Generator //////////////////////////////

/// BEGIN File Path Buffer //////////////////////////////
// This is a memory region where we store file paths for compile-file-into-ops operation.
// This buffer is created to ensure that the file path string live long enough for
// compile-file-into-ops to process the files properly.
const FPB_CAP 32 1024 * end
memory fpb-start FPB_CAP end
memory fpb-size sizeof(u64) end

inline proc fpb-end -- ptr in fpb-start fpb-size @64 ptr+ end
inline proc fpb-rewind ptr in fpb-start ptr-diff fpb-size !int end

proc fpb-alloc
  int
  --
  ptr // result
in
  dup fpb-size @64 + FPB_CAP > if
    here eputs ": File Path Buffer capacity exceeded.\n" eputs
    1 exit
  end

  dup 0 fpb-end memset
  fpb-size @64 rot + fpb-size !64
end

inline proc fpb-append int ptr -- ptr in over fpb-alloc memcpy end
/// END File Path Buffer //////////////////////////////

/// BEGIN Compiler //////////////////////////////
const PARSE_BLOCK_STACK_CAP 1024 end
memory parse-block-stack-count sizeof(u64) end
memory parse-block-stack sizeof(u64) PARSE_BLOCK_STACK_CAP * end

proc parse-block-stack-push int in
  parse-block-stack-count @64 PARSE_BLOCK_STACK_CAP >= if
    here eputs ": ERROR: parse block stack overflow\n" eputs 1 exit
  end
  parse-block-stack parse-block-stack-count @64 sizeof(u64) * ptr+ !64
  parse-block-stack-count inc64
end

proc parse-block-stack-pop -- int in
  parse-block-stack-count @64 0 = if
    here eputs ": ERROR: parse block stack underflow\n" eputs 1 exit
  end
  parse-block-stack-count dec64
  parse-block-stack parse-block-stack-count @64 sizeof(u64) * ptr+ @64
end

proc parse-block-stack-top -- int bool in
  parse-block-stack-count @64 0 = if
    0 false
  else
    parse-block-stack parse-block-stack-count @64 1 - sizeof(u64) * ptr+ @64
    true
  end
end

const ConstFrame.type sizeof(u64) offset end
const ConstFrame.value sizeof(u64) offset end
const sizeof(ConstFrame) reset end

const CONST_STACK_CAP 1024 end
memory const-stack-count sizeof(u64) end
memory const-stack sizeof(ConstFrame) CONST_STACK_CAP * end
memory iota sizeof(int) end

inline proc const-stack-clean in
  0 const-stack-count !64
end

proc const-stack-push
  int // type
  int // value
in
  memory frame sizeof(ConstFrame) end
  frame ConstFrame.value ptr+ !64
  frame ConstFrame.type ptr+ !64

  sizeof(ConstFrame) frame CONST_STACK_CAP const-stack const-stack-count append-item lnot if
    here eputs ": TODO: const stack overflow\n" eputs
    1 exit
  end
  drop
end

proc const-stack-pop
  --
  int // type
  int // value
in
  const-stack-count @64 0 <= if
    here eputs ": Assertion Failed: const stack underflow\n" eputs
    1 exit
  end

  const-stack-count dec64
  const-stack-count @64 sizeof(ConstFrame) * const-stack +ptr
  dup ConstFrame.type ptr+ @64
  swap ConstFrame.value ptr+ @64
end

proc const-expect-arity
  int // arity
  ptr // token
in
  memory token sizeof(ptr) end
  token !ptr

  const-stack-count @64 > if
    token @ptr Token.loc ptr+             eputloc
    ": ERROR: not enough arguments for `" eputs
    token @ptr Token.text ptr+ @Str       eputs
    "`\n"                                 eputs
    1 exit
  end
end

proc parse-after-call-like
  ptr // lexer
  --
  int
in
  memory lexer sizeof(ptr) end
  lexer !ptr
  memory token sizeof(Token) end

  token lexer @ptr lexer-next-token lnot if
    token Token.loc ptr+ lexer @ptr lexer-get-loc
    token Token.loc ptr+                               eputloc
    ": ERROR: expected procedure name after keyword `" eputs
    KEYWORD_CALL_LIKE keyword-name                     eputs
    "`. But got nothing.\n"                            eputs
    1 exit
  end

  token Token.type ptr+ @int
    dup TOKEN_WORD != if
      token Token.loc ptr+                       eputloc
      ": ERROR: expected "                       eputs
      TOKEN_WORD HUMAN_SINGULAR human-token-type eputs
      " after keyword `"                         eputs
      KEYWORD_CALL_LIKE keyword-name             eputs
      "` but got "                               eputs
      dup HUMAN_SINGULAR human-token-type        eputs
      "\n"                                       eputs
      1 exit
    end
  drop

  memory result sizeof(int) end

  token Token.value ptr+
    dup @Str proc-lookup-by-name
      dup NULL ptr= if
        token Token.loc ptr+   eputloc
        ": ERROR: procedure `" eputs
        over @Str              eputs
        "` does not exist\n"   eputs
        1 exit
      end

      dup procs ptr-diff sizeof(Proc) / result !int
    drop
  drop

  result @int
end

proc parse-after-addr-of
  ptr // lexer
  --
  int
in
  memory lexer sizeof(ptr) end
  lexer !ptr
  memory token sizeof(Token) end

  token lexer @ptr lexer-next-token lnot if
    token Token.loc ptr+ lexer @ptr lexer-get-loc
    token Token.loc ptr+                               eputloc
    ": ERROR: expected procedure name after keyword `" eputs
    KEYWORD_ADDR_OF keyword-name                       eputs
    "`. But got nothing.\n"                            eputs
    1 exit
  end

  token Token.type ptr+ @int
    dup TOKEN_WORD != if
      token Token.loc ptr+                       eputloc
      ": ERROR: expected "                       eputs
      TOKEN_WORD HUMAN_SINGULAR human-token-type eputs
      " after keyword `"                         eputs
      KEYWORD_ADDR_OF keyword-name               eputs
      "` but got "                               eputs
      dup HUMAN_SINGULAR human-token-type        eputs
      "\n"                                       eputs
      1 exit
    end
  drop

  memory result sizeof(int) end

  token Token.value ptr+
    dup @Str proc-lookup-by-name
      dup NULL ptr= if
        token Token.loc ptr+   eputloc
        ": ERROR: procedure `" eputs
        over @Str              eputs
        "` does not exist\n"   eputs
        1 exit
      end

      dup Proc.addr ptr+ @int result !int
    drop
  drop

  result @int
end

proc eval-const-value
  ptr // ptr to lexer
  --
  int // type
  int // value
in
  memory lexer sizeof(ptr) end
  lexer !ptr

  memory token sizeof(Token) end
  memory done sizeof(bool) end
  false done !64

  const-stack-clean

  while
    done @bool lnot if
      token lexer @ptr lexer-next-token
    else false end
  do
    token Token.type ptr+ @64 TOKEN_INT = if
      DATATYPE_INT token Token.value ptr+ @64 const-stack-push
    else token Token.type ptr+ @64 TOKEN_WORD = if*
      token Token.value ptr+ @Str intrinsic-by-name if
        assert "Exhaustive handling of casts in eval-const-value" COUNT_DATATYPES 4 = end
        dup INTRINSIC_CAST_PTR = if
          1 token const-expect-arity
          const-stack-pop
          swap drop
          DATATYPE_PTR swap
          const-stack-push
        else dup INTRINSIC_CAST_BOOL = if*
          1 token const-expect-arity
          const-stack-pop
          swap drop
          DATATYPE_BOOL swap
          const-stack-push
        else dup INTRINSIC_CAST_ADDR = if*
          1 token const-expect-arity
          const-stack-pop
          swap drop
          DATATYPE_ADDR swap
          const-stack-push
        else dup INTRINSIC_CAST_INT = if*
          1 token const-expect-arity
          const-stack-pop
          swap drop
          DATATYPE_INT swap
          const-stack-push
        else dup INTRINSIC_MINUS = if*
          2 token const-expect-arity
          // TODO: `-` intrinsic ignores the types in compile time evaluation
          const-stack-pop swap drop
          const-stack-pop swap drop
          swap
          -
          DATATYPE_INT swap const-stack-push
        else dup INTRINSIC_PLUS = if*
          2 token const-expect-arity
          // TODO: `+` intrinsic ignores the types in compile time evaluation
          const-stack-pop swap drop
          const-stack-pop swap drop
          swap
          +
          DATATYPE_INT swap const-stack-push
        else dup INTRINSIC_MUL = if*
          2 token const-expect-arity
          // TODO: `*` intrinsic ignores the types in compile time evaluation
          const-stack-pop swap drop
          const-stack-pop swap drop
          swap
          *
          DATATYPE_INT swap const-stack-push
        else dup INTRINSIC_EQ = if*
          2 token const-expect-arity
          // TODO: `=` intrinsic ignores the types in compile time evaluation
          const-stack-pop swap drop
          const-stack-pop swap drop
          swap
          = cast(int)
          DATATYPE_BOOL swap const-stack-push
        else dup INTRINSIC_MAX = if*
          2 token const-expect-arity
          // TODO: `max` intrinsic ignores the types in compile time evaluation
          const-stack-pop swap drop
          const-stack-pop swap drop
          swap
          max
          DATATYPE_INT swap const-stack-push
        else dup INTRINSIC_DIVMOD = if*
          2 token const-expect-arity
          // TODO: `divmod` intrinsic ignores the types in compile time evaluation
          const-stack-pop swap drop
          const-stack-pop swap drop
          swap
          divmod
          swap
          DATATYPE_INT swap const-stack-push
          DATATYPE_INT swap const-stack-push
        else dup INTRINSIC_DROP = if*
          1 token const-expect-arity
          const-stack-pop drop drop
        else
          token Token.loc ptr+ eputloc ": ERROR: intrinsic `" eputs token Token.value ptr+ @Str eputs "` is not supported in compile time evaluation\n" eputs
          1 exit
        end
      else token Token.value ptr+ @Str const-lookup dup NULL ptr!= if*
        dup Const.type ptr+ @64
        swap Const.value ptr+ @64
        const-stack-push
      else token Token.value ptr+ @Str try-parse-int if*
        DATATYPE_PTR swap const-stack-push
        drop // const
      else
        drop // try-parse-int
        drop // const
        token Token.loc ptr+             eputloc
        ": ERROR: unsupported word `"    eputs
        token Token.value ptr+ @Str      eputs
        "` in compile time evaluation\n" eputs
        1 exit
      end
      drop // intrinsic
    else token Token.type ptr+ @64 TOKEN_KEYWORD = if*
      assert "Exhaustive handling of keywords in eval-const-value" COUNT_KEYWORDS 22 = end
      token Token.value ptr+ @64
        dup KEYWORD_END = if
          true done !64
        else dup KEYWORD_OFFSET = if*
          1 token const-expect-arity
          const-stack-pop swap drop // TODO: offset ignores the type
          DATATYPE_INT iota @int const-stack-push
          iota @int + iota !int
        else dup KEYWORD_RESET = if*
          DATATYPE_INT iota @int const-stack-push
          0 iota !int
        else dup KEYWORD_ADDR_OF = if*
          DATATYPE_ADDR
          lexer @ptr parse-after-addr-of
          const-stack-push
        else
          token Token.loc ptr+             eputloc
          ": ERROR: unsupported keyword `" eputs
          dup keyword-name                 eputs
          "` in compile time evaluation\n" eputs
          1 exit
        end
      drop
    else
      token Token.loc ptr+                                    eputloc
      ": ERROR: "                                             eputs
      token Token.type ptr+ @64 HUMAN_PLURAL human-token-type eputs
      " are not supported in compile time evaluation\n"       eputs
      1 exit
    end
  end

  done @bool if
    const-stack-count @64 1 != if
      token Token.loc ptr+ eputloc
      ": ERROR: The result of expression in compile time evaluation must be a single number\n" eputs
      1 exit
    end

    const-stack-pop
  else
    here eputs ": TODO: const expression was not closed properly\n" eputs
    1 exit
    0 0
  end
end

proc check-name-redefinition
  int ptr // name
  ptr     // loc
in
  memory loc sizeof(Loc) end
  sizeof(Loc) swap loc memcpy drop
  memory name sizeof(Str) end
  name !Str

  name @Str intrinsic-by-name if
    loc                                            eputloc
    ": ERROR: redefinition of an intrinsic word `" eputs
    name @Str                                      eputs
    "`\n"                                          eputs
    1 exit
  end drop

  name @Str const-lookup dup NULL ptr!= if
    loc eputloc ": ERROR: redefinition of a constant `" eputs name @Str eputs "`\n" eputs
    dup Const.loc ptr+ eputloc ": NOTE: the original definition is located here\n" eputs
    1 exit
  end drop

  name @Str proc-lookup-by-name dup NULL ptr!= if
    loc eputloc ": ERROR: redefinition of a procedure `" eputs name @Str eputs "`\n" eputs
    dup Proc.loc ptr+ eputloc ": NOTE: the original definition is located here\n" eputs
    1 exit
  end drop

  name @Str local-memories-lookup dup NULL ptr!= if
    loc eputloc ": ERROR: redefinition of a local memory region `" eputs name @Str eputs "`\n" eputs
    dup Memory.loc ptr+ eputloc ": NOTE: the original definition is located here\n" eputs
    1 exit
  end drop

  inside-proc @bool lnot if
    name @Str global-memories-lookup dup NULL ptr!= if
      loc eputloc ": ERROR: redefinition of a global memory region `" eputs name @Str eputs "`\n" eputs
      dup Memory.loc ptr+ eputloc ": NOTE: the original definition is located here\n" eputs
      1 exit
    end drop
  end
end

proc parse-proc-contract-list
  ptr  // lexer
  ptr  // type stack
  --
  bool // encountered `--`
in
  memory stack sizeof(ptr) end
  stack !ptr
  memory lexer sizeof(ptr) end
  lexer !ptr
  memory token sizeof(Token) end
  memory bikeshedder sizeof(bool) end
  false bikeshedder !bool

  while
    token lexer @ptr lexer-next-token if
      token Token.type ptr+ @int TOKEN_WORD = if
        token Token.value ptr+
          dup @Str datatype-by-name if
            token Token.loc ptr+
            stack @ptr
            type-stack-push
            true // continue
          else
            drop
            token Token.loc ptr+          eputloc
            ": ERROR: unknown type `"     eputs
            // TODO: everything that's coming from the user (a.k.a. source code) must be escaped before being printed on the screen
            // Otherwise if the name of the type (in this specific case) contains any special control characters (like '\r') for example. The entire diagnostic is gonna be corrupted rendering it useless
            dup @Str                      eputs
            "` in procedure definition\n" eputs
            1 exit
            false // break, compile error
          end
          swap
        drop
      else token Token.type ptr+ @int TOKEN_KEYWORD = if*
        token Token.value ptr+ @int
          dup KEYWORD_IN = if
            false // break, reached the end of list
          else dup KEYWORD_BIKESHEDDER = if*
            true bikeshedder !bool
            false // break, reached the end of list
          else
            token Token.loc ptr+            eputloc
            ": ERROR: unexpected keyword `" eputs
            dup keyword-name                eputs
            "` in procedure definition\n"   eputs
            1 exit
            false // break, compile error
          end
          swap
        drop
      else
        token Token.loc ptr+                                     eputloc
        ": ERROR: "                                              eputs
        token Token.type ptr+ @int HUMAN_PLURAL human-token-type eputs
        " are not supported in procedure definition. Only "      eputs
        TOKEN_WORD HUMAN_PLURAL human-token-type                 eputs
        " are supported.\n"                                      eputs
        1 exit
        false // break, compile error
      end
    else
      false // break, ran out of tokens
    end
  do end

  bikeshedder @bool
end

proc introduce-proc
  ptr // token
  ptr // lexer
  bool // inline
in
  memory inlinable sizeof(bool) end
  inlinable !bool
  memory lexer_ sizeof(ptr) end
  lexer_ !ptr
  memory token sizeof(Token) end
  sizeof(Token) swap token memcpy drop
  memory prok sizeof(Proc) end

  inside-proc @bool if
    token Token.loc ptr+                                                             eputloc
    ": ERROR: definition procedures inside of procedures is not allowed (for now)\n" eputs
    procs-count @int 1 - sizeof(Proc) * procs +ptr Proc.loc ptr+                     eputloc
    ": NOTE: the current procedure starts here\n"                                    eputs
    1 exit
  end

  sizeof(Proc) 0 prok memset drop

  inlinable @bool prok Proc.inlinable ptr+ !bool

  token lexer_ @ptr lexer-next-token lnot if
    token Token.loc ptr+ eputloc
    ": ERROR: expected procedure name but found nothing\n" eputs
    1 exit
  end

  token Token.type ptr+ @64 TOKEN_WORD != if
    token Token.loc ptr+ eputloc
    ": ERROR: expected procedure name to be a word but found " eputs
    token Token.type ptr+ @64 HUMAN_SINGULAR human-token-type eputs
    " instead\n" eputs
    1 exit
  end

  sizeof(Loc) token Token.loc ptr+ prok Proc.loc ptr+ memcpy drop

  token Token.value ptr+ @Str
  token Token.loc ptr+
  check-name-redefinition

  sizeof(Str) token Token.value ptr+ prok Proc.name ptr+ memcpy drop

  ops-count @64
  dup prok Proc.addr ptr+ !64
      parse-block-stack-push
  OP_PREP_PROC 0 token push-op

  prok
    lexer_ @ptr over Proc.ins ptr+ parse-proc-contract-list if
      lexer_ @ptr over Proc.outs ptr+ parse-proc-contract-list drop
    end
  drop

  true inside-proc !bool

  prok proc-define
end

proc introduce-import
  ptr // token
  ptr // lexer
in
  memory lexer_ sizeof(ptr) end
  lexer_ !ptr
  memory token sizeof(Token) end
  sizeof(Token) swap token memcpy drop
  memory prok sizeof(Proc) end

  inside-proc @bool if
    token Token.loc ptr+                                                             eputloc
    ": ERROR: definition procedures inside of procedures is not allowed (for now)\n" eputs
    procs-count @int 1 - sizeof(Proc) * procs +ptr Proc.loc ptr+                     eputloc
    ": NOTE: the current procedure starts here\n"                                    eputs
    1 exit
  end

  sizeof(Proc) 0 prok memset drop

  true prok Proc.imported ptr+ !bool

  token lexer_ @ptr lexer-next-token lnot if
    token Token.loc ptr+ eputloc
    ": ERROR: expected procedure name but found nothing\n" eputs
    1 exit
  end

  token Token.type ptr+ @64 TOKEN_WORD != if
    token Token.loc ptr+ eputloc
    ": ERROR: expected procedure name to be a word but found " eputs
    token Token.type ptr+ @64 HUMAN_SINGULAR human-token-type eputs
    " instead\n" eputs
    1 exit
  end

  sizeof(Loc) token Token.loc ptr+ prok Proc.loc ptr+ memcpy drop

  token Token.value ptr+ @Str
  token Token.loc ptr+
  check-name-redefinition

  sizeof(Str) token Token.value ptr+ prok Proc.name ptr+ memcpy drop

  ops-count @64
  dup prok Proc.addr ptr+ !64
      parse-block-stack-push
  OP_PREP_PROC 0 token push-op

  lexer_ @ptr prok Proc.ins ptr+ parse-proc-contract-list if
    token Token.loc ptr+ eputloc
    ": ERROR: bikeshedder are not supported in imported procedures" eputs
    1 exit
  end

  true inside-proc !bool

  prok proc-define
end

proc inline-procedure
  ptr // proc
  ptr // token
in
  memory token sizeof(Token) end
  sizeof(Token) swap token memcpy drop
  memory prok sizeof(ptr) end
  prok !ptr

  prok @ptr Proc.addr ptr+ @int sizeof(Op) * ops +ptr

  dup Op.type ptr+ @int OP_PREP_PROC != if
    here eputs ": Assertion Failed: procedures must start with OP_PREP_PROC\n" eputs
    1 exit
  end

  OP_INLINED
  prok @ptr Proc.addr ptr+ @int
  token
  push-op

  // TODO: this is unsafe and can easily overflow ops array
  sizeof(Op) ptr+
  while dup Op.type ptr+ @int OP_RET != do
    dup push-op-by-ptr
    sizeof(Op) ptr+
  end
  drop
end

proc current-proc -- ptr in
  inside-proc @bool if
    procs-count @int
    1 -
    sizeof(Proc) *
    procs +ptr
  else
    NULL
  end
end

const BIND_TABLE_CAP 1024 end
memory bind-table sizeof(Str) BIND_TABLE_CAP * end
memory bind-table-count sizeof(int) end

proc bind-table-push int ptr in
  bind-table-count @int BIND_TABLE_CAP >= if
    here eputs ": Assertion Failed: bind table overflow!\n" eputs
    1 exit
  end

  bind-table-count @int
  sizeof(Str) *
  bind-table +ptr
  !Str

  bind-table-count inc64
end

proc bind-table-lookup
  int ptr
  --
  int bool
in
  memory name sizeof(Str) end
  name !Str

  bind-table-count @int 1 -
  while
    dup 0 >= if
      dup sizeof(Str) * bind-table +ptr @Str
      name @Str
      streq
      lnot
    else false end
  do 1 - end

  dup 0 >= if
    bind-table-count @int
    swap 1 +
    -
    true
  else
    false
  end
end

proc bind-table-rev-top int in
  bind-table-count @int
  let n cap in
    n cap > if
      here eputs ": Assertion Failed: not enough elements to reverse in bind-table-rev-top" eputs
      1 exit
    end

    cap n -
    cap 1 -
    while over over < do
      let i j in
        i sizeof(Str) * bind-table +ptr
        j sizeof(Str) * bind-table +ptr
        let a b in
          a @Str
          b @Str
          a !Str
          b !Str
        end
        i 1 +
        j 1 -
      end
    end
    drop
    drop
  end
end

// TODO: consider merging the process of compilation and type checking
// - Helps to catch type errors earlier
// - Allows `???` to show the type stack even if the program is not fully compilable

proc parse-bind-list
  ptr // lexer
  --
  int
in
  memory lexer sizeof(ptr) end
  lexer !ptr
  memory count sizeof(int) end
  0 count !int
  memory token sizeof(Token) end

  while
    token lexer @ptr lexer-next-token if
      token Token.type ptr+ @int
        dup TOKEN_WORD = if
          token Token.value ptr+ @Str bind-table-push
          count inc64
          true
        else dup TOKEN_KEYWORD = if*
          token Token.value ptr+ @int
            dup KEYWORD_IN = if
              false
            else
              token Token.loc ptr+                            eputloc
              ": ERROR: keyword `"                            eputs
              dup keyword-name                                eputs
              "` is not supported in the let-binding list.\n" eputs
              1 exit
              false
            end
          swap drop
        else
          token Token.loc ptr+                                     eputloc
          ": ERROR: "                                              eputs
          token Token.type ptr+ @int HUMAN_PLURAL human-token-type eputs
          " are not supported in the let-binding list. Only "      eputs
          TOKEN_WORD HUMAN_PLURAL human-token-type                 eputs
          " are supported.\n"                                      eputs
          1 exit
          false // break
        end
      swap drop
    else
      token Token.loc ptr+
      dup lexer @ptr lexer-get-loc
      eputloc
      ": ERROR: expected keyword `" eputs
      KEYWORD_IN keyword-name       eputs
      "` but got nothing\n"         eputs
      1 exit

      false // break
    end
  do end

  count @int bind-table-rev-top

  count @int
end

// TODO: more reliable id of the file we've already included
// Full path should suffice for now. Not sure if we wanna go into
// realpath kinda business with resolving symlinks and other crazy stuff.
const Module.path sizeof(ptr) offset end
const Module.finished sizeof(bool) offset end
const sizeof(Module) reset end

const MODULES_CAP 1024 end
memory modules sizeof(Module) MODULES_CAP * end
memory modules-count sizeof(int) end

proc module-lookup
  ptr // full-path cstr
  --
  ptr
in
  let path-cstr in
    0 while
      dup modules-count @int < if
        dup sizeof(Module) * modules +ptr
        let module in
          module Module.path ptr+ @ptr
          path-cstr
          cstreq
          lnot
        end
      else false end
    do 1 + end

    let index in
      index modules-count @int < if
        index sizeof(Module) * modules +ptr
      else
        NULL
      end
    end
  end
end

proc module-start
  ptr // full-path cstr
  --
  ptr
in
  modules-count @int MODULES_CAP >= if
    here eputs ": Assertion Failed: modules overflow\n" eputs
    1 exit
  end

  let path-cstr in
    modules-count @int
    sizeof(Module) *
    modules +ptr

    modules-count inc64

    let module in
      path-cstr module Module.path ptr+ !ptr
      false     module Module.finished  ptr+ !bool
      module
    end
  end
end

const INCLUDE_PATHS_CAP 1024 end
memory include-paths sizeof(Str) INCLUDE_PATHS_CAP * end
memory include-paths-count sizeof(int) end

proc include-paths-add
  int ptr
in
  include-paths-count @int
  let n s count in
    count INCLUDE_PATHS_CAP >= if
      here eputs ": Assertion Failed: include paths capacity overflow\n" eputs
      1 exit
    end

    n s
    count sizeof(Str) * include-paths +ptr
    !Str

    include-paths-count inc64
  end
end

proc include-paths-resolve-file
  int ptr
  --
  int ptr
  bool
in
  let n s in
    0
    tmp-end
    while
      peek i path in
        i include-paths-count @int < if
          i sizeof(Str) * include-paths +ptr @Str tmp-append drop
          "/"                                     tmp-append drop
          n s                                     tmp-append drop
          1                                       tmp-alloc  drop
          path ?file-exist lnot
        else false end
      end
    do
      let i path in
        i 1 +
        path dup tmp-rewind
      end
    end

    let i path in
      i include-paths-count @int < if
        path cstr-to-str normpath true
      else
        str-null false
      end
    end
  end
end

proc compile-file-into-ops
  ptr  // file path cstr
in
  let file-path-cstr in
    tmp-end
      sizeof(Lexer) tmp-alloc
      sizeof(Token) tmp-alloc
      let lexer token in
        sizeof(Lexer) 0 lexer memset drop
        file-path-cstr map-file    lexer Lexer.content   ptr+ !Str
        file-path-cstr cstr-to-str lexer Lexer.file-path ptr+ !Str

        false inside-proc !64

        while token lexer lexer-next-token do
          assert "Exhaustive handling of Token types" COUNT_TOKENS 6 = end

          token Token.type ptr+
          token Token.loc ptr+
          token Token.value ptr+

          let type loc value in
            type @int TOKEN_INT = if
              inside-proc @bool lnot if
                loc                                                  eputloc
                ": ERROR: "                                          eputs
                type @int HUMAN_PLURAL human-token-type              eputs
                " are not allowed at the top level of the program\n" eputs
                1 exit
              end

              OP_PUSH_INT value @int token push-op
            else type @int TOKEN_KEYWORD = if*
              value @int
              let keyword in
                assert "Exhaustive handling of keywords in compile-file-into-ops" COUNT_KEYWORDS 22 = end
                keyword KEYWORD_IF = if
                  ops-count @64 parse-block-stack-push
                  OP_IF 0 token push-op
                else keyword KEYWORD_IFSTAR = if*
                  parse-block-stack-top
                  let else-ip ok in
                    ok lnot if
                      loc eputloc ": ERROR: `if*` can only come after `else`, but found nothing\n" eputs
                      1 exit
                    end

                    else-ip sizeof(Op) * ops +ptr Op.type ptr+ @int OP_ELSE != if
                      loc eputloc ": ERROR: `if*` can only come after `else`\n" eputs
                      1 exit
                    end
                  end

                  ops-count @int parse-block-stack-push
                  OP_IFSTAR 0 token push-op
                else keyword KEYWORD_ELSE = if*
                  parse-block-stack-count @int 0 <= if
                    loc eputloc
                    ": ERROR: `else` can only come after `if` or `if*`\n" eputs
                    1 exit
                  end

                  parse-block-stack-pop
                  dup sizeof(Op) * ops +ptr
                  dup Op.type ptr+ @int
                  let if-ip if-op if-type in
                    if-type OP_IF = if
                      ops-count @int
                      let current-ip in
                        current-ip if-ip - 1 + if-op Op.operand ptr+ !64
                        current-ip parse-block-stack-push
                        OP_ELSE 0 token push-op
                      end
                    else if-type OP_IFSTAR = if*
                      parse-block-stack-pop
                      dup sizeof(Op) * ops +ptr
                      ops-count @int
                      let else-ip else-op current-ip in
                        else-op Op.type ptr+ @int OP_ELSE != if
                          here eputs ": Assertion Failed: expected OP_ELSE\n" eputs
                          1 exit
                        end

                        current-ip if-ip   - 1 + if-op   Op.operand ptr+ !int
                        current-ip else-ip -     else-op Op.operand ptr+ !int
                        current-ip parse-block-stack-push
                      end
                      OP_ELSE 0 token push-op
                    else
                      loc eputloc
                      ": ERROR: `else` can only come after `if` or `if*`\n" eputs
                      1 exit
                    end
                  end
                else keyword KEYWORD_WHILE = if*
                  ops-count @64 parse-block-stack-push
                  OP_WHILE 0 token push-op
                else keyword KEYWORD_DO = if*
                  parse-block-stack-count @64 0 <= if
                    loc eputloc ": ERROR: `do` is not preceded by `while`\n" eputs
                    1 exit
                  end

                  parse-block-stack-pop
                  dup sizeof(Op) * ops +ptr
                  dup Op.type ptr+ @int
                  over Op.token ptr+
                  let
                    while-ip while-op while-type while-token
                  in
                    while-type OP_WHILE != if
                      loc                                          eputloc
                      ": ERROR: `do` is not preceded by `while`\n" eputs
                      while-token Token.loc  ptr+                  eputloc
                      ": NOTE: preceded by `"                      eputs
                      while-token Token.text ptr+ @Str             eputs
                      "` instead\n"                                eputs
                      1 exit
                    end

                    ops-count @64 parse-block-stack-push
                    // NOTE: temporarily storring the absolute address
                    // of OP_WHILE in OP_DO operand so we can use it
                    // for OP_END_WHILE later.
                    //
                    // TODO: Maybe we should use block-stack for now?
                    //
                    // - rexim 06.02.2022
                    OP_DO while-ip token push-op
                  end
                else keyword KEYWORD_END = if*
                  parse-block-stack-count @64 0 <= if
                    loc eputloc
                    ": ERROR: `end` has nothing to close\n" eputs
                    1 exit
                  end

                  parse-block-stack-pop   // ip
                  dup sizeof(Op) * ops +ptr // op
                  dup Op.type ptr+ @int
                  let
                    begin-ip begin-op begin-type
                  in
                    begin-type OP_IF = if
                      ops-count @int begin-ip - begin-op Op.operand ptr+ !int
                      OP_END_IF 0 token push-op
                    else begin-type OP_IFSTAR = if*
                      parse-block-stack-pop
                      dup sizeof(Op) * ops +ptr
                      let else-ip else-op in
                        else-op Op.type ptr+ @int OP_ELSE != if
                          here eputs ": Assertion Failed: `else-if*-end` chain is broken. Lost `else` somewhere.\n" eputs
                          loc located-here
                          1 exit
                        end

                        ops-count @int begin-ip - 1 + begin-op Op.operand ptr+ !int
                        ops-count @int else-ip  -     else-op  Op.operand ptr+ !int

                        OP_END_IF 0 token push-op
                      end
                    else begin-type OP_ELSE = if*
                      ops-count @int begin-ip - begin-op Op.operand ptr+ !int
                      OP_END_IF 0 token push-op
                    else begin-type OP_DO = if*
                      begin-op Op.operand ptr+ @int
                      let while-ip in
                        while-ip ops-count @int >= if
                          here eputs ": Assertion Failed: out of range\n" eputs
                          1 exit
                        end

                        while-ip sizeof(Op) * ops +ptr
                        let while-op in
                          while-op Op.type ptr+ @int OP_WHILE != if
                            here eputs ": Assertion Failed: `do` does not preceed `while`\n" eputs
                            1 exit
                          end

                          ops-count @int
                          let current-ip in
                            OP_END_WHILE current-ip while-ip - token push-op

                            current-ip 1 + begin-ip - begin-op Op.operand ptr+ !int
                            current-ip 1 + while-ip - while-op Op.operand ptr+ !int
                          end
                        end
                      end
                    else begin-type OP_PREP_PROC = if*
                      local-memory-capacity @64
                      begin-op Op.operand ptr+
                      !64

                      // Compute the size of the procedure
                      current-proc
                      let prok in
                        prok ?null if
                          here eputs ": Assertion failed: OP_PREP_PROC outside of actual proc\n" eputs
                          loc located-here
                          1 exit
                        end

                        ops-count @int
                        prok Proc.addr ptr+ @int -
                        1 -

                        prok Proc.size ptr+ !int
                      end

                      OP_RET
                      local-memory-capacity @64
                      token
                      push-op

                      local-memories-clean
                      false inside-proc !bool
                    else begin-type OP_BIND_LET = begin-type OP_BIND_PEEK = lor if*
                      begin-op Op.operand ptr+ @int
                      let bind-count in
                        OP_UNBIND bind-count token push-op

                        bind-table-count @int bind-count < if
                          here eputs ": Assertion Failed: bind table underflow!\n" eputs
                          1 exit
                        end

                        bind-table-count @int
                        bind-count -
                        bind-table-count !int
                      end
                    else
                      begin-op Op.token ptr+
                      let begin-token in
                        loc                                                                                         eputloc
                        ": ERROR: `end` can only close `if`, `if*`, `else`, `do`, `proc`, `let` or `peek` blocks\n" eputs
                        begin-token Token.loc ptr+                                                                  eputloc
                        ": NOTE: found `"                                                                           eputs
                        begin-token Token.text ptr+ @Str                                                            eputs
                        "` instead\n"                                                                               eputs
                      end
                      1 exit
                    end
                  end
                else keyword KEYWORD_INCLUDE = if*
                  token lexer lexer-next-token lnot if
                    loc eputloc
                    ": ERROR: expected path to the include file but found nothing\n" eputs
                    1 exit
                  end

                  type @int TOKEN_STR != if
                    loc                                                                    eputloc
                    ": ERROR: expected path to the include file to be a string but found " eputs
                    type @int HUMAN_SINGULAR human-token-type                              eputs
                    "\n"                                                                   eputs
                    1 exit
                  end

                  tmp-end
                  let s in
                    value @Str include-paths-resolve-file lnot if
                      loc               eputloc
                      ": ERROR: file `" eputs
                      value @Str        eputs
                      "` not found\n"   eputs
                      1 exit
                    end

                    let n s in
                      fpb-end
                      n s fpb-append drop
                      1 fpb-alloc drop

                      fpb-end
                      n s abspath fpb-append drop
                      1 fpb-alloc drop
                    end
                    s tmp-rewind
                  end

                  let include-path abs-include-path in
                    abs-include-path module-lookup
                    let module in
                      module NULL ptr= if
                        abs-include-path module-start
                          silent @bool lnot if
                            "[INFO] Including "      puts
                            include-path cstr-to-str puts
                            "\n"                     puts
                          end
                          include-path compile-file-into-ops
                        true swap Module.finished ptr+ !bool
                      else module Module.finished ptr+ @bool lnot if*
                        // TODO: report more information on detected loop
                        // Preferably the whole "path" of the loop
                        //
                        // When we allow arbitrary order of definitions
                        // this may not be necessary anymore, cause we may
                        // simply allow include loops and the arbitrary
                        // order should resolve everything.
                        //
                        // - rexim 05.02.2022
                        loc                       eputloc
                        ": ERROR: include loop\n" eputs
                        1 exit
                      end
                    end
                  end
                else keyword KEYWORD_CONST = if*
                  token lexer lexer-next-token lnot if
                    loc eputloc
                    ": expected constant name but found nothing\n" eputs
                    1 exit
                  end

                  type @int TOKEN_WORD != if
                    // TODO: report what was found instead of a word
                    loc                                       eputloc
                    ": expected constant name to be a word\n" eputs
                    1 exit
                  end

                  value @Str loc check-name-redefinition

                  tmp-end
                    sizeof(Const) tmp-alloc
                    let konst in
                      value @Str konst Const.name ptr+ !Str
                      sizeof(Loc) loc konst Const.loc ptr+ memcpy drop

                      lexer eval-const-value
                      konst Const.value ptr+ !64
                      konst Const.type ptr+ !64
                      konst const-define
                    end
                  tmp-rewind
                else keyword KEYWORD_IMPORT = if*
                  token lexer lexer-next-token lnot if
                    loc eputloc
                    ": ERROR: expected `proc` keyword after `import` but got nothing\n" eputs
                    1 exit
                  end

                  type  @int TOKEN_KEYWORD =
                  value @int KEYWORD_PROC  =
                  land lnot if
                    loc                                                         eputloc
                    ": ERROR: Expected keyword `proc` after `import` but got `" eputs
                    token Token.text ptr+ @Str                                  eputs
                    "`\n"                                                       eputs
                    1 exit
                  end
                  token lexer introduce-import
                else keyword KEYWORD_INLINE = if*
                  token lexer lexer-next-token lnot if
                    loc eputloc
                    ": ERROR: expected `proc` keyword after `inline` but got nothing\n" eputs
                    1 exit
                  end

                  type  @int TOKEN_KEYWORD =
                  value @int KEYWORD_PROC  =
                  land lnot if
                    loc                                                         eputloc
                    ": ERROR: Expected keyword `proc` after `inline` but got `" eputs
                    token Token.text ptr+ @Str                                  eputs
                    "`\n"                                                       eputs
                    1 exit
                  end

                  token lexer true introduce-proc
                else keyword KEYWORD_PROC = if*
                  token lexer false introduce-proc
                else keyword KEYWORD_MEMORY = if*
                  token lexer lexer-next-token lnot if
                    loc eputloc
                    ": expected memory name but found nothing\n" eputs
                    1 exit
                  end

                  type @int TOKEN_WORD != if
                    loc                                              eputloc
                    ": expected memory name to be a word but found " eputs
                    type @int HUMAN_SINGULAR human-token-type        eputs
                    " instead\n"                                     eputs
                    1 exit
                  end

                  value @Str loc check-name-redefinition

                  tmp-end
                    sizeof(Memory) tmp-alloc
                    let memori in
                      sizeof(Str) value memori Memory.name ptr+ memcpy drop
                      sizeof(Loc) loc   memori Memory.loc  ptr+ memcpy drop

                      lexer eval-const-value
                      let const-type memory-size in
                        const-type DATATYPE_INT != if
                          loc                                     eputloc
                          ": ERROR: Expected memory size to be `" eputs
                          DATATYPE_INT datatype-name              eputs
                          "` but got `"                           eputs
                          const-type datatype-name                eputs
                          "` instead\n"                           eputs
                          1 exit
                        end

                        // NOTE: align all the memories to the size of the word
                        memory-size
                        7 +
                        8 /
                        8 *

                        current-proc
                        let prok in
                          prok NULL ptr!= if
                            prok Proc.inlinable ptr+ @bool if
                              loc                                                                     eputloc
                              ": ERROR: local memories are not allowed in inlinable procedures yet\n" eputs
                              prok Proc.loc ptr+                                                      eputloc
                              ": NOTE: the procedure starts here\n"                                   eputs
                              1 exit
                            end

                            local-memory-capacity @int memori Memory.offset ptr+ !int
                            local-memory-capacity @int + local-memory-capacity !int
                            memori local-memory-define
                          else
                            global-memory-capacity @int memori Memory.offset ptr+ !int
                            global-memory-capacity @int + global-memory-capacity !int
                            memori global-memory-define
                          end
                        end
                      end
                    end
                  tmp-rewind
                else keyword KEYWORD_ASSERT = if*
                  token lexer lexer-next-token lnot if
                    loc eputloc
                    ": expected assert message but found nothing\n" eputs
                    1 exit
                  end

                  type @int TOKEN_STR != if
                    // TODO: report what was found instead of a string
                    loc                                          eputloc
                    ": expected assert message to be a string\n" eputs
                    1 exit
                  end

                  lexer eval-const-value
                  let assert-type assert-value in
                    assert-type DATATYPE_BOOL != if
                      loc eputloc ": ERROR: assertion expects the expression to be of type `bool`\n" eputs
                      1 exit
                    end

                    assert-value cast(bool) lnot if
                      loc eputloc ": ERROR: Static Assertion Failed: " eputs value @Str eputs "\n" eputs
                      1 exit
                    end
                  end
                else keyword KEYWORD_HERE = if*
                  OP_PUSH_STR
                  loc strbuf-loc strlit-define
                  token
                  push-op
                else keyword KEYWORD_ADDR_OF = if*
                  OP_PUSH_ADDR
                  lexer parse-after-addr-of
                  token // TODO: the token refers to `addr-of` keyword, but not the name of the procedure the address
                        // of which we are taking.
                  push-op
                else keyword KEYWORD_CALL_LIKE = if*
                  OP_CALL_LIKE
                  lexer parse-after-call-like
                  token // TODO: the token refers to `call-like` keyword, but not the name of the procedure the address
                        // of which we are taking.
                  push-op
                else keyword KEYWORD_LET = if*
                  ops-count @int
                  parse-block-stack-push

                  OP_BIND_LET
                  lexer parse-bind-list
                  token
                  push-op
                else keyword KEYWORD_PEEK = if*
                  ops-count @int
                  parse-block-stack-push

                  OP_BIND_PEEK
                  lexer parse-bind-list
                  token
                  push-op
                else
                  loc                             eputloc
                  ": ERROR: unexpected keyword `" eputs
                  keyword keyword-name            eputs
                  "`\n"                           eputs
                  1 exit
                end
              end
            else type @int TOKEN_WORD = if*
              inside-proc @bool lnot if
                loc                                                      eputloc
                ": ERROR: "                                              eputs
                token Token.type ptr+ @int HUMAN_PLURAL human-token-type eputs
                " are not allowed at the top level of the program\n"     eputs
                1 exit
              end

              value // token.value
                assert "Exhaustive handling of Op types in compile-file-into-ops" COUNT_OPS 25 = end
                dup @Str intrinsic-by-name if
                  OP_INTRINSIC swap token push-op
                else drop dup @Str bind-table-lookup if*
                  OP_PUSH_BIND
                  swap
                  token
                  push-op
                else drop dup @Str const-lookup dup NULL ptr!= if*
                  dup Const.type ptr+ @int
                  assert "Exhaustive handling of data types in Const compilation\n" COUNT_DATATYPES 4 = end
                  dup DATATYPE_INT = if
                    drop OP_PUSH_INT
                  else dup DATATYPE_BOOL = if*
                    drop OP_PUSH_BOOL
                  else dup DATATYPE_PTR = if*
                    drop OP_PUSH_PTR
                  else dup DATATYPE_ADDR = if*
                    drop OP_PUSH_ADDR
                  else
                    drop 0
                    here eputs ": unreachable\n" eputs
                    69 exit
                  end
                  swap Const.value ptr+ @64
                  token
                  push-op
                else drop dup @Str proc-lookup-by-name dup NULL ptr!= if*
                  dup Proc.inlinable ptr+ @bool if
                    current-proc
                      over over ptr= if
                        // TODO: inline recursion prevention mechanism does not detect mutual recursion
                        // Which is fine for now cause we do not even support mutual recursion.
                        // But when we do, this might bite us in the ass. Which it will I'm 100% sure.
                        // So this TODO is kinda pointless. But let's keep it in here just in case.
                        loc                           eputloc
                        ": ERROR: no recursion in inline procedures\n" eputs
                        1 exit
                      end
                    drop

                    token
                    inline-procedure
                  else
                    OP_CALL
                    swap Proc.addr ptr+ @64
                    token
                    push-op
                  end
                else drop dup @Str local-memories-lookup dup NULL ptr!= if*
                  // TODO: local memory regions can shadow the global ones
                  // Do we wanna warn the user about that?
                  OP_PUSH_LOCAL_MEM
                    swap Memory.offset ptr+ @64
                    bind-table-count @int 8 * // NOTE: let bindings do offset the local memories
                    +
                  token
                  push-op
                else drop dup @Str global-memories-lookup dup NULL ptr!= if*
                  OP_PUSH_GLOBAL_MEM
                  swap Memory.offset ptr+ @64
                  token
                  push-op
                else drop
                  loc      eputloc
                  ": ERROR: unknown word `" eputs
                  dup @Str                  eputs
                  "`\n"                     eputs
                  1 exit
                end
              drop // token.value
            else type @int TOKEN_STR = if*
              inside-proc @bool lnot if
                loc                                     eputloc
                ": ERROR: "                                              eputs
                token Token.type ptr+ @int HUMAN_PLURAL human-token-type eputs
                " are not allowed at the top level of the program\n"     eputs
                1 exit
              end

              OP_PUSH_STR
              value @Str strlit-define
              token
              push-op
            else type @int TOKEN_CSTR = if*
              inside-proc @bool lnot if
                loc                                     eputloc
                ": ERROR: "                                              eputs
                token Token.type ptr+ @int HUMAN_PLURAL human-token-type eputs
                " are not allowed at the top level of the program\n"     eputs
                1 exit
              end

              OP_PUSH_CSTR
              value @Str strlit-define
              token
              push-op
            else type @int TOKEN_CHAR = if*
              inside-proc @bool lnot if
                loc                                     eputloc
                ": ERROR: "                                              eputs
                token Token.type ptr+ @int HUMAN_PLURAL human-token-type eputs
                " are not allowed at the top level of the program\n"     eputs
                1 exit
              end

              OP_PUSH_INT
              value @int
              token
              push-op
            else
              here eputs ": Unreachable. Unknown token type.\n" eputs
              1 exit
            end
          end

        end

        parse-block-stack-count @64 0 > if
          parse-block-stack-pop
          sizeof(Op) *
          ops +ptr

          dup Op.token ptr+ Token.loc ptr+ eputloc ": ERROR: unclosed block\n" eputs

          1 exit
          drop
        end
      end
    tmp-rewind
  end
end
/// END Compiler //////////////////////////////

proc type-check-frames
  int // args count
  ptr // actual frame
  ptr // expected frame
  ptr // token
in
  memory token sizeof(ptr) end
  token !ptr
  memory expected sizeof(ptr) end
  expected !ptr
  memory actual sizeof(ptr) end
  actual !ptr
  memory args-count sizeof(int) end
  args-count !int

  expected @ptr TypeFrame.type ptr+ @int
  actual   @ptr TypeFrame.type ptr+ @int
  != if
    token @ptr Token.loc ptr+                            eputloc
    ": ERROR: Argument "                                 eputs
    args-count @int                                      eputu
    " of `"                                              eputs
    token @ptr Token.text ptr+ @Str                      eputs
    "` is expected to be type `"                         eputs
    expected @ptr TypeFrame.type ptr+ @int datatype-name eputs
    "` but got type `"                                   eputs
    actual @ptr TypeFrame.type ptr+ @int datatype-name   eputs
    "`\n"                                                eputs

    actual @ptr TypeFrame.loc ptr+                       eputloc
    ": NOTE: Argument "                                  eputs
    args-count @int                                      eputu
    " was provided here\n"                               eputs

    expected @ptr TypeFrame.loc ptr+                     eputloc
    ": NOTE: Expected type was declared here\n"          eputs

    1 exit
  end
end

proc expect-arity
  ptr // token
  ptr // stack
  int // arity
  --
  ptr // dst
in
  memory arity sizeof(int) end
  arity !int
  memory stack sizeof(ptr) end
  stack !ptr
  memory token sizeof(ptr) end
  token !ptr
  memory dst sizeof(ptr) end
  sizeof(TypeStack) tmp-alloc dst !ptr
  memory tmp sizeof(TypeStack) end
  sizeof(TypeStack) 0 tmp memset drop

  stack @ptr TypeStack.count ptr+ @int
  arity @int
  < if
    token @ptr Token.loc ptr+                      eputloc
    ": ERROR: Not enough arguments provided for `" eputs
    token @ptr Token.text ptr+ @Str                eputs
    "`. Expected "                                 eputs
    arity @int                                     eputu
    " but got "                                    eputs
    stack @ptr TypeStack.count ptr+ @int           eputu
    ".\n"                                          eputs
    1 exit
  end

  stack @ptr TypeStack.top ptr+ @ptr
    0
      while dup arity @int < do
        swap
          dup TypeFrame.type ptr+ @int
          over TypeFrame.loc ptr+
          tmp
          type-stack-push

          TypeFrame.prev ptr+ @ptr
        swap
        1 +
      end
    drop
  drop

  0 while dup arity @int < do
    tmp TypeStack.top ptr+ @ptr
      dup  TypeFrame.type ptr+ @int
      over TypeFrame.loc ptr+
      dst @ptr
      type-stack-push
    drop
    tmp type-stack-pop
    1 +
  end drop

  dst @ptr
end

// TODOO: porth.porth allows memory in inline procs for some reason

// TODO: warning about unused names

proc compile-program-into-ops ptr in
  let file-path-cstr in
    include-paths-count @int
      // NOTE: Temporarily adding the folder the source is located in to the include paths
      // and then removing it at the end of the compilation
      //
      // - rexim 01.02.2022
      file-path-cstr cstr-to-str dirname include-paths-add

      timeit/from-here
        file-path-cstr module-lookup NULL ptr!= if
          here eputs ": Assertion Failed: the entry module should not be included at this point\n" eputs
          1 exit
        end

        // TODO: should we normalize the entry module path before the compilation?
        file-path-cstr module-start
          silent @bool lnot if
            "[INFO] Compiling "        puts
            file-path-cstr cstr-to-str puts
            "\n"                       puts
          end
          file-path-cstr compile-file-into-ops
        true swap Module.finished ptr+ !bool
      "[INFO] Compilation" silent @bool timeit/to-here
    include-paths !int
  end
end

// TODOOO: rename expect-arity-2 to expect-arity when there are no use cases for the original expect-arity anymore
// the main difference between them is that expect-arity-2 does not allocate dst in tmp region, but rather accepts it
// via the arguments
proc expect-arity-2
  ptr // token
  ptr // stack
  int // arity
  ptr // dst
in
  memory dst sizeof(ptr) end
  dst !ptr
  memory arity sizeof(int) end
  arity !int
  memory stack sizeof(ptr) end
  stack !ptr
  memory token sizeof(ptr) end
  token !ptr
  memory tmp sizeof(TypeStack) end
  sizeof(TypeStack) 0 tmp memset drop

  stack @ptr TypeStack.count ptr+ @int
  arity @int
  < if
    token @ptr Token.loc ptr+                      eputloc
    ": ERROR: Not enough arguments provided for `" eputs
    token @ptr Token.text ptr+ @Str                eputs
    "`. Expected "                                 eputs
    arity @int                                     eputu
    " but got "                                    eputs
    stack @ptr TypeStack.count ptr+ @int           eputu
    ".\n"                                          eputs
    1 exit
  end

  stack @ptr TypeStack.top ptr+ @ptr
    0
      while dup arity @int < do
        swap
          dup TypeFrame.type ptr+ @int
          over TypeFrame.loc ptr+
          tmp
          type-stack-push

          TypeFrame.prev ptr+ @ptr
        swap
        1 +
      end
    drop
  drop

  0 while dup arity @int < do
    tmp TypeStack.top ptr+ @ptr
      dup  TypeFrame.type ptr+ @int
      over TypeFrame.loc ptr+
      dst @ptr
      type-stack-push
    drop
    tmp type-stack-pop
    1 +
  end drop
end

proc type-check-stack
  ptr // token
  ptr // stack
  ptr // ins
  ptr // outs
in
  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) swap outs memcpy drop
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) swap ins memcpy drop
  memory stack sizeof(ptr) end
  stack !ptr
  memory token sizeof(ptr) end
  token !ptr

  0 // args count
    while
      stack @ptr ?type-stack-empty
      ins        ?type-stack-empty
      lor
      lnot
    do
      dup
      stack @ptr TypeStack.top ptr+ @ptr
      ins        TypeStack.top ptr+ @ptr
      token @ptr
      type-check-frames

      stack @ptr type-stack-pop
      ins        type-stack-pop
      1 +
    end

    ins ?type-stack-empty lnot if
      token @ptr Token.loc ptr+                       eputloc
      ": ERROR: Not enough arguments provided for `"  eputs
      token @ptr Token.text ptr+ @Str                 eputs
      "`. Expected "                                  eputs
      dup ins TypeStack.count ptr+ @int +             eputu
      " but got "                                     eputs
      dup                                             eputu
      ".\n"                                           eputs
      here eputs ": TODO: reporting not provided arguments is not implemented\n" eputs
      1 exit
    end
  drop // args count

  outs type-stack-reverse TypeStack.top ptr+ @ptr
  while dup NULL ptr!= do
    dup TypeFrame.type ptr+ @int
    token @ptr Token.loc ptr+
    stack @ptr
    type-stack-push

    TypeFrame.prev ptr+ @ptr
  end drop
end

proc type-check-over
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over over 2 ins expect-arity-2

  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) ins outs memcpy drop
  ins TypeStack.top ptr+ @ptr TypeFrame.prev ptr+ @ptr
  outs
  type-stack-push-frame

  ins outs type-check-stack
end

proc type-check-rot
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over over 3 ins expect-arity-2

  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) 0 outs memset drop

  ins TypeStack.top ptr+ @ptr
  TypeFrame.prev ptr+ @ptr
  outs type-stack-push-frame

  ins TypeStack.top ptr+ @ptr
  outs type-stack-push-frame

  ins TypeStack.top ptr+ @ptr
  TypeFrame.prev ptr+ @ptr
  TypeFrame.prev ptr+ @ptr
  outs type-stack-push-frame

  ins outs type-check-stack
end

proc type-check-dup
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over over 1 ins expect-arity-2

  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) ins outs memcpy drop
  ins TypeStack.top ptr+ @ptr
  outs
  type-stack-push-frame

  ins outs type-check-stack
end

proc type-check-binary-int-operator
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over
    DATATYPE_INT over Token.loc ptr+ ins type-stack-push
    DATATYPE_INT over Token.loc ptr+ ins type-stack-push
  drop
  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) 0 outs memset drop
  over
    DATATYPE_INT over Token.loc ptr+ outs type-stack-push
  drop
  ins outs type-check-stack
end

proc type-check-if-op
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over
    DATATYPE_BOOL over Token.loc ptr+ ins type-stack-push
  drop
  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) 0 outs memset drop
  ins outs type-check-stack
end

proc type-check-store-operator
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over over 2 ins expect-arity-2
  DATATYPE_PTR ins TypeStack.top ptr+ @ptr TypeFrame.type ptr+ !int

  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) 0 outs memset drop

  ins outs type-check-stack
end

proc type-check-load-operator
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over
    DATATYPE_PTR over Token.loc ptr+ ins type-stack-push
  drop
  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) 0 outs memset drop
  over
    DATATYPE_INT over Token.loc ptr+ outs type-stack-push
  drop
  ins outs type-check-stack
end

proc type-check-unary-int-operator
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over
    DATATYPE_INT over Token.loc ptr+ ins type-stack-push
  drop
  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) 0 outs memset drop
  over
    DATATYPE_INT over Token.loc ptr+ outs type-stack-push
  drop
  ins outs type-check-stack
end

proc type-check-cmp-int-operator
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over
    DATATYPE_INT over Token.loc ptr+ ins type-stack-push
    DATATYPE_INT over Token.loc ptr+ ins type-stack-push
  drop
  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) 0 outs memset drop
  over
    DATATYPE_BOOL over Token.loc ptr+ outs type-stack-push
  drop
  ins outs type-check-stack
end

proc type-check-divmod-operator
  ptr // token
  ptr // stack
in
  memory ins sizeof(TypeStack) end
  sizeof(TypeStack) 0 ins memset drop
  over
    DATATYPE_INT over Token.loc ptr+ ins type-stack-push
    DATATYPE_INT over Token.loc ptr+ ins type-stack-push
  drop
  memory outs sizeof(TypeStack) end
  sizeof(TypeStack) 0 outs memset drop
  over
    DATATYPE_INT over Token.loc ptr+ outs type-stack-push
    DATATYPE_INT over Token.loc ptr+ outs type-stack-push
  drop
  ins outs type-check-stack
end

proc type-check-call-like
  ptr // op
  ptr // stack
in
  memory stack sizeof(ptr) end
  stack !ptr
  memory op sizeof(ptr) end
  op !ptr
  memory ins sizeof(TypeStack) end
  memory outs sizeof(TypeStack) end

  // TODO: assert if the index to the procedure valid
  op @ptr Op.operand ptr+ @int sizeof(Proc) * procs +ptr
    sizeof(TypeStack) over Proc.ins  ptr+ ins  memcpy drop
    sizeof(TypeStack) over Proc.outs ptr+ outs memcpy drop
  drop

  DATATYPE_ADDR
  op @ptr Op.token ptr+ Token.loc ptr+
  ins
  type-stack-push

  op @ptr Op.token ptr+
  stack @ptr
  ins
  outs
  type-check-stack
end

const TypeContext.stack sizeof(TypeStack) offset end
const TypeContext.ip sizeof(int) offset end
const TypeContext.outs sizeof(TypeStack) offset end
const TypeContext.block-start-ip sizeof(int) offset end
const TypeContext.ret sizeof(TypeStack) offset end
const sizeof(TypeContext) reset end

proc type-context-from-parts
  ptr // stack
  int // ip
  ptr // outs
  int // ip beginning of the type checking block
  ptr // ret
  ptr // the type context
  --
  ptr // the type context
in
  memory context sizeof(ptr) end
  context !ptr

  sizeof(TypeStack) swap context @ptr TypeContext.ret ptr+ memcpy drop
  context @ptr TypeContext.block-start-ip ptr+ !int
  sizeof(TypeStack) swap context @ptr TypeContext.outs ptr+ memcpy drop
  context @ptr TypeContext.ip ptr+ !int
  sizeof(TypeStack) swap context @ptr TypeContext.stack ptr+ memcpy drop

  context @ptr
end

proc type-check-peek
  int // bind count
  ptr // token
  ptr // context
in
  let bind-count token context in
    context TypeContext.stack ptr+ TypeStack.count ptr+ @int
    let stack-size in
      stack-size bind-count < if
        token Token.loc ptr+ eputloc
        ": ERROR: Data stack does not have enough elements to bind. Expected " eputs
        bind-count eputu
        " but got " eputs
        stack-size eputu
        ". Here is the data stack: \n" eputs
        context @ptr TypeContext.stack ptr+ stderr type-stack-dump
        1 exit
      end
    end

    bind-count
    context TypeContext.stack ptr+ TypeStack.top ptr+ @ptr
    while over 0 > do
      let bind-count top in
        top
        context TypeContext.ret ptr+
        type-stack-push-frame

        bind-count 1 -
        top TypeFrame.prev ptr+ @ptr
      end
    end
    drop
    drop
  end
end

proc type-check-bind
  int // bind count
  ptr // token
  ptr // context
in
  memory context sizeof(ptr) end
  context !ptr

  memory token sizeof(Token) end
  sizeof(Token) swap token memcpy drop

  memory bind-count sizeof(int) end
  bind-count !int

  context @ptr TypeContext.stack ptr+ TypeStack.count ptr+ @int
  bind-count @int
  over over < if
    token Token.loc ptr+ eputloc
    ": ERROR: Data stack does not have enough elements to bind. Expected " eputs
    eputu
    " but got " eputs
    eputu
    ". Here is the data stack: \n" eputs
    context @ptr TypeContext.stack ptr+ stderr type-stack-dump
    1 exit
  else
    drop drop
  end

  while bind-count @int 0 > do
    context @ptr TypeContext.stack ptr+ TypeStack.top ptr+ @ptr
    context @ptr TypeContext.ret ptr+
    type-stack-push-frame

    context @ptr TypeContext.stack ptr+
    type-stack-pop

    bind-count dec64
  end
end

proc type-check-unbind
  int // bind count
  ptr // token
  ptr // context
in
  memory context sizeof(ptr) end
  context !ptr

  memory token sizeof(Token) end
  sizeof(Token) swap token memcpy drop

  dup
  context @ptr TypeContext.ret ptr+ TypeStack.count ptr+ @int
  > if
    here eputs ": Assertion Failed: the return stack does not have enough frames to unbind" eputs
    1 exit
  end

  memory bind-count sizeof(int) end
  bind-count !int

  while bind-count @int 0 > do
    context @ptr TypeContext.ret ptr+
    type-stack-pop

    bind-count dec64
  end
end

proc type-check-push-bind
  int // bind count
  ptr // token
  ptr // context
in
  let bind-count token context in
    bind-count
    context TypeContext.ret ptr+ TypeStack.count ptr+ @int
    > if
      here eputs ": Assertion Failed: the return stack does not have enough frames to address for OP_PUSH_BIND. This is likely a bug in the compilation process because it should've caught that.\n" eputs
      1 exit
    end

    bind-count
    context TypeContext.ret ptr+ TypeStack.top ptr+ @ptr
    while over 0 > do
      let count frame in
        count 1 -
        frame TypeFrame.prev ptr+ @ptr
      end
    end

    let _ frame in
      frame TypeFrame.type ptr+ @int
      token Token.loc ptr+
      context TypeContext.stack ptr+
      type-stack-push
    end
  end
end

proc type-check-program-from
  ptr // the type context
in
  memory context sizeof(TypeContext) end
  sizeof(TypeContext) swap context memcpy drop

  memory while-context sizeof(TypeContext) end

  memory op sizeof(Op) end

  type-frame-pool-count @int

  while
    tmp-end
    context TypeContext.ip ptr+ @int ops-count @int < if
      sizeof(Op)
      context TypeContext.ip ptr+ @int sizeof(Op) * ops +ptr
      op
      memcpy drop

      assert "Exhaustive handling of Op types in type-check-program-from" COUNT_OPS 25 = end

      op Op.type ptr+ @int OP_PUSH_INT = if
        DATATYPE_INT
        op Op.token ptr+ Token.loc ptr+
        context TypeContext.stack ptr+
        type-stack-push

        context TypeContext.ip ptr+ inc64

        true // continue
      else op Op.type ptr+ @int OP_PUSH_BOOL = if*
        DATATYPE_BOOL
        op Op.token ptr+ Token.loc ptr+
        context TypeContext.stack ptr+
        type-stack-push

        context TypeContext.ip ptr+ inc64

        true // continue
      else op Op.type ptr+ @int OP_PUSH_PTR = if*
        DATATYPE_PTR
        op Op.token ptr+ Token.loc ptr+
        context TypeContext.stack ptr+
        type-stack-push

        context TypeContext.ip ptr+ inc64

        true // continue
      else op Op.type ptr+ @int OP_PUSH_ADDR = if*
        DATATYPE_ADDR
        op Op.token ptr+ Token.loc ptr+
        context TypeContext.stack ptr+
        type-stack-push

        context TypeContext.ip ptr+ inc64

        true // continue
      else op Op.type ptr+ @int OP_PUSH_LOCAL_MEM = if*
        DATATYPE_PTR
        op Op.token ptr+ Token.loc ptr+
        context TypeContext.stack ptr+
        type-stack-push

        context TypeContext.ip ptr+ inc64

        true // continue
      else op Op.type ptr+ @int OP_PUSH_GLOBAL_MEM = if*
        DATATYPE_PTR
        op Op.token ptr+ Token.loc ptr+
        context TypeContext.stack ptr+
        type-stack-push

        context TypeContext.ip ptr+ inc64

        true // continue
      else op Op.type ptr+ @int OP_PUSH_STR = if*
        op Op.token ptr+ Token.loc ptr+
          DATATYPE_INT over context TypeContext.stack ptr+ type-stack-push
          DATATYPE_PTR over context TypeContext.stack ptr+ type-stack-push
        drop

        context TypeContext.ip ptr+ inc64

        true // continue
      else op Op.type ptr+ @int OP_PUSH_CSTR = if*
        op Op.token ptr+ Token.loc ptr+
          DATATYPE_PTR over context TypeContext.stack ptr+ type-stack-push
        drop

        context TypeContext.ip ptr+ inc64

        true  // continue
      else op Op.type ptr+ @int OP_IF = if*
        op Op.token ptr+ context TypeContext.stack ptr+ type-check-if-op

        // then branch
        context TypeContext.ip ptr+ inc64
        context type-check-program-from
        context TypeContext.ip ptr+ dec64

        // else branch
        context TypeContext.ip ptr+
        let ip in
          ip @int
          op Op.operand ptr+ @int
          +
          ip !int
        end
        true // continue
      else op Op.type ptr+ @int OP_IFSTAR = if*
        op Op.token ptr+ context TypeContext.stack ptr+ type-check-if-op

        // then branch
        context TypeContext.ip ptr+ inc64
        context type-check-program-from
        context TypeContext.ip ptr+ dec64

        // else branch
        context TypeContext.ip ptr+
        let ip in
          ip @int
          op Op.operand ptr+ @int
          +
          ip !int
        end
        true // continue
      else op Op.type ptr+ @int OP_ELSE = if*
        context TypeContext.ip ptr+
        let ip in
          ip @int
          op Op.operand ptr+ @int
          +
          ip !int
        end
        true // continue
      else op Op.type ptr+ @int OP_END_IF = if*
        context TypeContext.ip ptr+ inc64
        true // continue
      else op Op.type ptr+ @int OP_END_WHILE = if*
        context TypeContext.ip ptr+
        let ip in
          ip @int
          op Op.operand ptr+ @int
          -
          ip !int
        end
        true // continue
      else op Op.type ptr+ @int OP_PREP_PROC = if*
        context TypeContext.ip ptr+ inc64
        true // continue
      else op Op.type ptr+ @int OP_RET = if*
        false // break, end of the procedure
      else op Op.type ptr+ @int OP_CALL = if*
        op Op.token ptr+
        context TypeContext.stack ptr+
        op Op.operand ptr+ @int proc-lookup-by-addr
          dup NULL ptr= if
            here eputs ": Assertion Failed: expect proc always exist with this specific address. Something went wrong during the compilation process\n" eputs
            1 exit
          end
          dup  Proc.ins  ptr+
          swap Proc.outs ptr+
        type-check-stack

        context TypeContext.ip ptr+ inc64

        true // continue
      else op Op.type ptr+ @int OP_CALL_LIKE = if*
        op context TypeContext.stack ptr+ type-check-call-like
        context TypeContext.ip ptr+ inc64

        true // continue
      else op Op.type ptr+ @int OP_BIND_LET = if*
        op Op.operand ptr+ @int
        op Op.token ptr+
        context
        type-check-bind

        context TypeContext.ip ptr+ inc64
        true // continue
      else op Op.type ptr+ @int OP_BIND_PEEK = if*
        op Op.operand ptr+ @int
        op Op.token ptr+
        context
        type-check-peek

        context TypeContext.ip ptr+ inc64
        true // continue
      else op Op.type ptr+ @int OP_UNBIND = if*
        op Op.operand ptr+ @int
        op Op.token ptr+
        context
        type-check-unbind

        context TypeContext.ip ptr+ inc64
        true // continue
      else op Op.type ptr+ @int OP_PUSH_BIND = if*
        op Op.operand ptr+ @int
        op Op.token ptr+
        context
        type-check-push-bind

        context TypeContext.ip ptr+ inc64
        true // continue
      else op Op.type ptr+ @int OP_INLINED = if*
        op Op.token ptr+
        context TypeContext.stack ptr+
        op Op.operand ptr+ @int proc-lookup-by-addr
          dup NULL ptr= if
            here eputs ": Assertion Failed: expect proc always exist with this specific address. Something went wrong during the compilation process\n" eputs
            1 exit
          end
          dup  Proc.ins  ptr+
          swap Proc.outs ptr+
        type-check-stack

        context TypeContext.ip ptr+ @int
        op Op.operand ptr+ @int proc-lookup-by-addr
        dup NULL ptr= if
          here eputs ": Assertion Failed: expect proc always exist with this specific address. Something went wrong during the compilation process\n" eputs
          1 exit
        end
        Proc.size ptr+ @int +
        1 +
        context TypeContext.ip ptr+ !int

        true // continue
      else op Op.type ptr+ @int OP_WHILE = if*
        context TypeContext.ip ptr+ @int
        context TypeContext.block-start-ip ptr+ @int != if
          context TypeContext.stack ptr+
          context TypeContext.ip ptr+ @int 1 +
          context TypeContext.stack ptr+
          context TypeContext.ip ptr+ @int
          context TypeContext.ret ptr+
          while-context
          type-context-from-parts
          type-check-program-from

          context TypeContext.ip ptr+
          let ip in
            ip @int
            op Op.operand ptr+ @int +
            ip !int
          end
          true // continue
        else
          false // break, we repeated the loop
        end
      else op Op.type ptr+ @int OP_DO = if*
        op Op.token ptr+ context TypeContext.stack ptr+ type-check-if-op

        // then branch
        context TypeContext.ip ptr+ inc64
        context type-check-program-from
        context TypeContext.ip ptr+ dec64

        // else branch
        false // break
      else op Op.type ptr+ @int OP_INTRINSIC = if*
        assert "Exhaustive handling of Intrinsics in type-check-program-from" COUNT_INTRINSICS 47 = end

        op Op.operand ptr+ @int
          dup INTRINSIC_PLUS = if
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-binary-int-operator
          else dup INTRINSIC_MINUS = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-binary-int-operator
          else dup INTRINSIC_MUL = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-binary-int-operator
          else dup INTRINSIC_DIVMOD = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-divmod-operator
          else dup INTRINSIC_IDIVMOD = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-divmod-operator
          else dup INTRINSIC_MAX = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-binary-int-operator
          else dup INTRINSIC_EQ = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-cmp-int-operator
          else dup INTRINSIC_GT = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-cmp-int-operator
          else dup INTRINSIC_LT = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-cmp-int-operator
          else dup INTRINSIC_GE = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-cmp-int-operator
          else dup INTRINSIC_LE = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-cmp-int-operator
          else dup INTRINSIC_NE = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-cmp-int-operator
          else dup INTRINSIC_SHR = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-binary-int-operator
          else dup INTRINSIC_SHL = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-binary-int-operator
          else dup INTRINSIC_OR = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-binary-int-operator
          else dup INTRINSIC_XOR = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-binary-int-operator
          else dup INTRINSIC_AND = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-binary-int-operator
          else dup INTRINSIC_NOT = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-unary-int-operator
          else dup INTRINSIC_PRINT = if*
            op Op.token ptr+
            context TypeContext.stack ptr+
            over over 1 expect-arity
            sizeof(TypeStack) tmp-alloc
            type-check-stack
          else dup INTRINSIC_DUP = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-dup
          else dup INTRINSIC_SWAP = if*
            // token
            op Op.token ptr+
            // stack
            context TypeContext.stack ptr+
            // ins
            over over 2 expect-arity
            // outs
            dup type-stack-reverse
            type-check-stack
          else dup INTRINSIC_DROP = if*
            op Op.token ptr+
            context TypeContext.stack ptr+
            over over 1 expect-arity
            sizeof(TypeStack) tmp-alloc
            type-check-stack
          else dup INTRINSIC_OVER = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-over
          else dup INTRINSIC_ROT = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-rot
          else dup INTRINSIC_LOAD8 = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-load-operator
          else dup INTRINSIC_STORE8 = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-store-operator
          else dup INTRINSIC_LOAD16 = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-load-operator
          else dup INTRINSIC_STORE16 = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-store-operator
          else dup INTRINSIC_LOAD32 = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-load-operator
          else dup INTRINSIC_STORE32 = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-store-operator
          else dup INTRINSIC_LOAD64 = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-load-operator
          else dup INTRINSIC_STORE64 = if*
            op Op.token ptr+ context TypeContext.stack ptr+ type-check-store-operator
          else dup INTRINSIC_CAST_PTR = if*
            op Op.token ptr+
            context TypeContext.stack ptr+
            over
            over
            1 expect-arity
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_PTR
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_CAST_INT = if*
            op Op.token ptr+
            context TypeContext.stack ptr+
            over
            over
            1 expect-arity
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_INT
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_CAST_BOOL = if*
            op Op.token ptr+
            context TypeContext.stack ptr+
            over
            over
            1 expect-arity
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_BOOL
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_CAST_ADDR = if*
            op Op.token ptr+
            context TypeContext.stack ptr+
            over
            over
            1 expect-arity
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_ADDR
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_ARGC = if*
            DATATYPE_INT
            op Op.token ptr+ Token.loc ptr+
            context TypeContext.stack ptr+
            type-stack-push
          else dup INTRINSIC_ARGV = if*
            DATATYPE_PTR
            op Op.token ptr+ Token.loc ptr+
            context TypeContext.stack ptr+
            type-stack-push
          else dup INTRINSIC_ENVP = if*
            DATATYPE_PTR
            op Op.token ptr+ Token.loc ptr+
            context TypeContext.stack ptr+
            type-stack-push
          else dup INTRINSIC_SYSCALL0 = if*
            // token
            op Op.token ptr+
            // stack
            context TypeContext.stack ptr+
            // ins
            over
            over
            1 expect-arity // TODO: replace it with a hardcoded stack (I just copy pasted this from other syscall implementations)
              DATATYPE_INT
              over
              TypeStack.top ptr+ @ptr
              TypeFrame.type ptr+
              !int
            // outs
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_INT
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_SYSCALL1 = if*
            // token
            op Op.token ptr+
            // stack
            context TypeContext.stack ptr+
            // ins
            over
            over
            2 expect-arity
              DATATYPE_INT
              over
              TypeStack.top ptr+ @ptr
              TypeFrame.type ptr+
              !int
            // outs
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_INT
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_SYSCALL2 = if*
            // token
            op Op.token ptr+
            // stack
            context TypeContext.stack ptr+
            // ins
            over
            over
            3 expect-arity
              DATATYPE_INT
              over
              TypeStack.top ptr+ @ptr
              TypeFrame.type ptr+
              !int
            // outs
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_INT
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_SYSCALL3 = if*
            // token
            op Op.token ptr+
            // stack
            context TypeContext.stack ptr+
            // ins
            over
            over
            4 expect-arity
              DATATYPE_INT
              over
              TypeStack.top ptr+ @ptr
              TypeFrame.type ptr+
              !int
            // outs
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_INT
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_SYSCALL4 = if*
            // token
            op Op.token ptr+
            // stack
            context TypeContext.stack ptr+
            // ins
            over
            over
            5 expect-arity
              DATATYPE_INT
              over
              TypeStack.top ptr+ @ptr
              TypeFrame.type ptr+
              !int
            // outs
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_INT
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_SYSCALL5 = if*
            // token
            op Op.token ptr+
            // stack
            context TypeContext.stack ptr+
            // ins
            over
            over
            6 expect-arity
              DATATYPE_INT
              over
              TypeStack.top ptr+ @ptr
              TypeFrame.type ptr+
              !int
            // outs
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_INT
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_SYSCALL6 = if*
            // token
            op Op.token ptr+
            // stack
            context TypeContext.stack ptr+
            // ins
            over
            over
            7 expect-arity
              DATATYPE_INT
              over
              TypeStack.top ptr+ @ptr
              TypeFrame.type ptr+
              !int
            // outs
            sizeof(TypeStack) tmp-alloc
              dup  DATATYPE_INT
              swap op Op.token ptr+ Token.loc ptr+
              swap type-stack-push
            type-check-stack
          else dup INTRINSIC_??? = if*
            op Op.token ptr+ Token.loc ptr+                             eputloc
            ": DEBUG: Stopping the compilation. Current stack state:\n" eputs
            context TypeContext.stack ptr+ stderr type-stack-dump
            1 exit
          else
            here eputs ": unreachable\n" eputs
            64 exit
          end
        drop

        context TypeContext.ip ptr+ inc64

        true // continue
      else
        here eputs ": unreachable\n" eputs
        69 exit

        false // break, though it does not really matter since this is unreachable state anyway
      end
    else
      false // break, we have reached the end of the program
    end
    swap tmp-rewind
  do end

  while
    context TypeContext.stack ptr+ ?type-stack-empty
    context TypeContext.outs ptr+  ?type-stack-empty
    lor
    lnot
  do
    context TypeContext.stack ptr+ TypeStack.top ptr+ @ptr TypeFrame.type ptr+ @int
    context TypeContext.outs ptr+  TypeStack.top ptr+ @ptr TypeFrame.type ptr+ @int
    != if
      context TypeContext.block-start-ip ptr+ @int sizeof(Op) * ops +ptr
        dup Op.type ptr+ @int OP_WHILE = if
          dup Op.token ptr+ Token.loc ptr+ eputloc
          dup Op.type ptr+ @int
            ": ERROR: Unexpected data on the stack after a single iteration of the loop. The types and the amount of elements on the stack are not allowed to change between the iterations.\n" eputs
          drop
        else dup Op.type ptr+ @int OP_PREP_PROC = if*
          dup Op.token ptr+ Token.loc ptr+ eputloc
          dup Op.type ptr+ @int
            ": ERROR: Unexpected data on the stack at the end of the procedure. The expected elements on the stack are listed after the `--` operator.\n" eputs
          drop
        else
          here               eputs
          ": unreachable "   eputs
          69 exit
        end
      drop

      context TypeContext.stack ptr+ TypeStack.top ptr+ @ptr
        dup TypeFrame.loc ptr+                     eputloc
        ": NOTE: Unexpected type `"                eputs
        dup TypeFrame.type ptr+ @int datatype-name eputs
        "`\n"                                      eputs
      drop

      context TypeContext.outs ptr+ TypeStack.top ptr+ @ptr
        dup TypeFrame.loc ptr+                       eputloc
        ": NOTE: Expected type `"                    eputs
        dup TypeFrame.type ptr+ @int datatype-name   eputs
        "`\n"                                        eputs
      drop

      1 exit
    end
    context TypeContext.stack ptr+ type-stack-pop
    context TypeContext.outs ptr+  type-stack-pop
  end

  context TypeContext.stack ptr+ TypeStack.count ptr+ @int
  context TypeContext.outs ptr+  TypeStack.count ptr+ @int
    over over > if
      context TypeContext.block-start-ip ptr+ @int sizeof(Op) * ops +ptr
        dup Op.type ptr+ @int OP_WHILE = if
          dup Op.token ptr+ Token.loc ptr+ eputloc
          dup Op.type ptr+ @int
            ": ERROR: Unhandled data on the stack after a single iteration of the loop. The types and the amount of elements on the stack are not allowed to change between the iterations. Here are the elements currently on the stack:\n" eputs
          drop
        else dup Op.type ptr+ @int OP_PREP_PROC = if*
          dup Op.token ptr+ Token.loc ptr+ eputloc
          dup Op.type ptr+ @int
            ": ERROR: Unhandled data on the stack at the end of the procedure. The expected elements on the stack are listed after the `--` operator. Here are the elements currently on the stack:\n" eputs
          drop
        else
          here               eputs
          ": unreachable "   eputs
          69 exit
        end
      drop
      context TypeContext.stack ptr+ stderr type-stack-dump

      1 exit
    end

    over over < if
      context TypeContext.block-start-ip ptr+ @int sizeof(Op) * ops +ptr
        dup Op.type ptr+ @int OP_WHILE = if
          dup Op.token ptr+ Token.loc ptr+ eputloc
          dup Op.type ptr+ @int
            ": ERROR: Insufficient data on the stack after a single iteration of the loop. The types and the amount of elements on the stack are not allowed to change between the iterations. Here are the elements currently on the stack:\n" eputs
          drop
        else dup Op.type ptr+ @int OP_PREP_PROC = if*
          dup Op.token ptr+ Token.loc ptr+ eputloc
          dup Op.type ptr+ @int
            ": ERROR: Insufficient data on the stack at the end of the procedure. The expected elements on the stack are listed after the `--` operator. Here are the elements currently on the stack:\n" eputs
          drop
        else
          here               eputs
          ": unreachable "   eputs
          69 exit
        end
      drop
      context TypeContext.outs ptr+ stderr type-stack-dump

      1 exit
    end
  drop
  drop
  type-frame-pool-count !int
end

// TODOO: multi-branch type check error reporting
proc type-check-program in
  memory prok sizeof(ptr) end

  timeit/from-here

  "main" proc-lookup-by-name
    dup NULL ptr= if
      "ERROR: `main` procedure was not provided\n" eputs
      1 exit
    end

    dup Proc.ins ptr+ ?type-stack-empty lnot if
      dup Proc.loc ptr+                                           eputloc
      ": ERROR: `main` procedure must not accept any arguments\n" eputs
      1 exit
    end

    dup Proc.outs ptr+ ?type-stack-empty lnot if
      dup Proc.loc ptr+                                      eputloc
      ": ERROR: `main` procedure must not return any data\n" eputs
      1 exit
    end
  drop

  memory context sizeof(TypeContext) end

  0 while dup procs-count @int < do
    dup sizeof(Proc) * procs +ptr
    prok !ptr

    sizeof(TypeContext) 0 context memset drop
    prok @ptr Proc.ins  ptr+
    prok @ptr Proc.addr ptr+ @int
    prok @ptr Proc.outs ptr+
    over
    context TypeContext.ret ptr+
    context

    type-context-from-parts

    type-check-program-from

    1 +
  end drop

  "[INFO] Type checking" silent @bool timeit/to-here
end

proc summary in
  "Ops count:                    " puts ops-count              @int putu "/" puts OPS_CAP             putu "\n" puts
  "Consts count:                 " puts consts-count           @int putu "/" puts CONST_CAP           putu "\n" puts
  "Procs count:                  " puts procs-count            @int putu "/" puts PROCS_CAP           putu "\n" puts
  "String literals count:        " puts strlits-count          @int putu "/" puts STRLITS_CAP         putu "\n" puts
  "String literals size (bytes): " puts strbuf-size            @int putu "/" puts STRBUF_CAP          putu "\n" puts
  "Global memories count:        " puts global-memories-count  @int putu "/" puts GLOBAL_MEMORIES_CAP putu "\n" puts
  // NOTE: global memory size does not have an upper capacity limit since it's
  // just a counter of how big of region to allocate in the .bss section
  "Global memory size (bytes):   " puts global-memory-capacity @int putu "\n" puts
  "Type Frames leaked:           " puts type-frame-pool-count  @int putu "/" puts TYPE_FRAME_POOL_CAP putu "\n" puts
  "Type Frame size (bytes):      " puts sizeof(TypeFrame) putu "\n" puts
end

proc usage
  ptr // program name
  int // fd
in
  let name fd in
    "Usage: " eputs name cstr-to-str puts " [OPTIONS] <SUBCOMMAND>\n"                          fd fputs
    "  OPTIONS:\n"                                                                             fd fputs
    "    -unsafe               Disable type checking.\n"                                       fd fputs
    "    -I <path>             Add <path> to the include paths list.\n"                        fd fputs
    "  SUBCOMMANDS:\n"                                                                         fd fputs
    "    com [OPTIONS] <file>  Compile the program\n"                                          fd fputs
    "      OPTIONS:\n"                                                                         fd fputs
    // TODO: implement -o flag for com subcommand
    "        -r                Run the program after successful compilation\n"                 fd fputs
    "        -b                Bundles the program to a linux executable. (If with -r, executes the bundle)\n" fd fputs
    "        -opt              Optimize the program with wasm-opt\n"                           fd fputs
    "        -wat              Transforms the labels stripped program back from `.wasm` to `.wat` \n"     fd fputs
    "        -s                Silent mode. Don't print any info about compilation phases\n"   fd fputs
    "    dump <file>           Dump the ops of the program\n"                                  fd fputs
    "    lex <file>            Produce lexical analysis of the file\n"                         fd fputs
    "    summary <file>        Print the summary of the program\n"                             fd fputs
    "    help                  Print this help to stdout and exit with 0 code\n"               fd fputs
  end
end

proc main in
  // Default include paths
  "."     include-paths-add
  "./std" include-paths-add

  memory args sizeof(ptr) end
  argv args !ptr

  memory program sizeof(ptr) end
  args @@ptr program !ptr

  memory unsafe sizeof(bool) end
  false unsafe !bool

  while
    args sizeof(ptr) inc64-by
    args @@ptr NULL ptr= if
      false // break
    else args @@ptr "-unsafe"c cstreq if*
      true unsafe !bool
      true  // continue
    else args @@ptr "-I"c cstreq if*
      args sizeof(ptr) inc64-by
      args @@ptr
        dup ?null if
          "ERROR: no argument is provided for -I flag\n" eputs
          1 exit
        end
        dup cstr-to-str include-paths-add
      drop
      true // continue
    else
      false // break
    end
  do end

  args @@ptr NULL ptr= if
    program @ptr stderr usage
    "ERROR: subcommand is not provided\n" eputs
    1 exit
  end

  memory input-file-path-cstr sizeof(ptr) end
  NULL input-file-path-cstr !ptr
  memory base-file-path sizeof(Str) end
  0 NULL base-file-path !Str
  memory run sizeof(bool) end
  false run !bool
  memory optimize sizeof(bool) end
  false optimize !bool
  memory wasm2wat sizeof(bool) end
  false wasm2wat !bool
  memory bundle sizeof(bool) end
  false bundle !bool

  args @@ptr "com"c cstreq if
    while
      args sizeof(ptr) inc64-by
      args @@ptr NULL ptr= if
        false // break
      else args @@ptr "-r"c cstreq if*
        true run !bool
        true  // continue
      else args @@ptr "-s"c cstreq if*
        true silent !bool
        true  // continue
      else args @@ptr "-b"c cstreq if*
        true bundle !bool
        true  // continue
      else args @@ptr "-opt"c cstreq if*
        true optimize !bool
        true  // continue
      else args @@ptr "-wat"c cstreq if*
        true wasm2wat !bool
        true  // continue
      else
        args @@ptr input-file-path-cstr !ptr
        args sizeof(ptr) inc64-by
        false // break
      end
    do end

    input-file-path-cstr @ptr NULL ptr= if
      program @ptr stderr usage
      "[ERROR] no input file is provided for the compilation.\n" eputs
      1 exit
    end

    input-file-path-cstr @ptr cstr-to-str remove-ext base-file-path !Str
    base-file-path @Str dirname append-std include-paths-add

    input-file-path-cstr @ptr compile-program-into-ops
    unsafe @bool lnot if type-check-program end

    timeit/from-here
      fpb-end
        base-file-path @Str fpb-append drop
        ".wat"              fpb-append drop
        1                   fpb-alloc  drop
        dup generate-wat
      fpb-rewind
    "[INFO] Generation" silent @bool timeit/to-here

    timeit/from-here
      cmd-dev-null-stdout @bool
        silent @bool cmd-dev-null-stdout !bool
        fpb-end
          tmp-end
          "wat2wasm"c           tmp-append-ptr
          fpb-end
            base-file-path @Str fpb-append drop
            ".wat"              fpb-append drop
            1                   fpb-alloc  drop
            tmp-append-ptr
          "-o"c                 tmp-append-ptr
          fpb-end
            base-file-path @Str fpb-append drop
            ".wasm"             fpb-append drop
            1                   fpb-alloc  drop
            tmp-append-ptr
          NULL          tmp-append-ptr
          silent @bool lnot cmd-echoed
        fpb-rewind
      cmd-dev-null-stdout !bool
    "[INFO] wat2wasm" silent @bool timeit/to-here

    optimize @bool if
      fpb-end
        tmp-end
        "wasm-opt"c             tmp-append-ptr
        "-Oz"c                  tmp-append-ptr
        "--zero-filled-memory"c tmp-append-ptr
        "--strip-producers"c    tmp-append-ptr
        "--enable-multivalue"c  tmp-append-ptr
        fpb-end
          base-file-path @Str fpb-append drop
          ".wasm"             fpb-append drop
          1                   fpb-alloc  drop
          tmp-append-ptr
          "-o"c                 tmp-append-ptr
          fpb-end
          base-file-path @Str fpb-append drop
          ".wasm"             fpb-append drop
          1                   fpb-alloc  drop
          tmp-append-ptr
        NULL          tmp-append-ptr
        silent @bool lnot cmd-echoed
      fpb-rewind
    end

    wasm2wat @bool if
      fpb-end
        tmp-end
        "wasm2wat"c             tmp-append-ptr
        fpb-end
          base-file-path @Str fpb-append drop
          ".wasm"              fpb-append drop
          1                   fpb-alloc  drop
          tmp-append-ptr
          "-o"c                 tmp-append-ptr
          fpb-end
          base-file-path @Str fpb-append drop
          ".wat"              fpb-append drop
          1                   fpb-alloc  drop
          tmp-append-ptr
        NULL          tmp-append-ptr
        silent @bool lnot cmd-echoed
      fpb-rewind
    end

    bundle @bool if
      fpb-end
        tmp-end
        "w4"c                  tmp-append-ptr
        "bundle"c              tmp-append-ptr
        "--linux"c             tmp-append-ptr
        fpb-end
          base-file-path @Str fpb-append drop
          1                   fpb-alloc  drop
          tmp-append-ptr
        fpb-end
          base-file-path @Str fpb-append drop
          ".wasm"             fpb-append drop
          1                   fpb-alloc  drop
          tmp-append-ptr
        NULL          tmp-append-ptr
        silent @bool lnot cmd-echoed
      fpb-rewind

      run @bool if
        fpb-end 
          tmp-end
          fpb-end
          base-file-path @Str fpb-append drop
          1                   fpb-alloc  drop
          tmp-append-ptr
          NULL          tmp-append-ptr
          silent @bool lnot cmd-echoed
        fpb-rewind
      end
    else run @bool if*
      fpb-end
        tmp-end
        "w4"c                 tmp-append-ptr
        "run"c                tmp-append-ptr
        fpb-end
          base-file-path @Str fpb-append drop
          ".wasm"             fpb-append drop
          1                   fpb-alloc  drop
          tmp-append-ptr
        NULL          tmp-append-ptr
        silent @bool lnot cmd-echoed
      fpb-rewind
    end

  else args @@ptr "help"c cstreq if*
    program @ptr stdout usage
    0 exit
  else args @@ptr "dump"c cstreq if*
    args sizeof(ptr) inc64-by
    args @@ptr NULL ptr= if
      program @ptr stderr usage
      "ERROR: no input file is provided for the `dump` subcommand\n" eputs
      1 exit
    end

    args @@ptr compile-program-into-ops
    unsafe @bool lnot if type-check-program end

    dump-ops
  else args @@ptr "lex"c cstreq if*
    args sizeof(ptr) inc64-by
    args @@ptr NULL ptr= if
      program @ptr stderr usage
      "ERROR: no input file is provided for the `lex` subcommand\n" eputs
      1 exit
    end

    args @@ptr lex-file
  else args @@ptr "summary"c cstreq if*
    args sizeof(ptr) inc64-by
    args @@ptr NULL ptr= if
      program @ptr stderr usage
      "ERROR: no input file is provided for the `dump` subcommand\n" eputs
      1 exit
    end

    args @@ptr compile-program-into-ops
    unsafe @bool lnot if type-check-program end

    summary
  else
    program @ptr stderr usage
    "ERROR: unknown subcommand `" eputs args @@ptr cstr-to-str eputs "`\n" eputs
    1 exit
  end
end
